{
  "source": "/Users/aaryanguglani/Downloads/Linux_System_Programming_Essentials-mkerrisk_man7.org.pdf",
  "extractedAt": "2025-12-22T16:02:07.941Z",
  "chapters": [
    {
      "title": "Untitled",
      "text": "\n\nLinux/UNIX\nSystem Programming\nEssentials\nMichael Kerrisk\nman7.org\nAugust 2025\n\n©2025, man7.org Training and Consulting /\nMichael Kerrisk (mtk@man7.org). All rights reserved.\nThese training materials have been made available for personal,\nnoncommercial use. Except for personal use, no part of these training\nmaterials may be printed, reproduced, or stored in a retrieval system. These\ntraining materials may not be redistributed by any means, electronic,\nmechanical, or otherwise, without prior written permission of the author. If\nyou find these materials hosted on a website other than the author’s own\nwebsite (http://man7.org/), then the materials are likely being distributed\nin breach of copyright. Please report such redistribution to the author.\nThese training materials may not be used to provide training to others\nwithout prior written permission of the author.\nEvery effort has been made to ensure that the material contained herein is\ncorrect, including the development and testing of the example programs.\nHowever, no warranty is expressed or implied, and the author shall not be\nliable for loss or damage arising from the use of these programs. The\nprograms are made available under Free Software licenses; see the header\ncomments of individual source files for details.\nFor information about this course, visit\nhttp://man7.org/training/.\nFor inquiries regarding training courses, please contact us at\ntraining@man7.org.\nPlease send corrections and suggestions for improvements to this\ncourse material totraining@man7.org.\nFor information aboutThe Linux Programming Interface, please\nvisithttp://man7.org/tlpi/.\nRevision: # caf166f4161b0 +++\n\nThis page intentionally blank\nThis page intentionally blank\n\nShort table of contents\n1  Course Introduction1-1\n2  Fundamental Concepts2-1\n3  File I/O3-1\n4  Processes4-1\n5  Signals5-1\n6  Process Lifecycle6-1\n7  System Call Tracing withstrace7-1\n8  Wrapup8-1\nThis page intentionally blank\n\nThis page intentionally blank\nThis page intentionally blank\n\nDetailed table of contents\n1  Course Introduction1-1\n1.1 Course overview1-3\n1.2 Course materials and resources1-9\n1.3 Common abbreviations1-13\n1.4 Introductions1-15\n2  Fundamental Concepts2-1\n2.1 Error handling2-3\n2.2 System data types2-10\n2.3 Notes on code examples2-15\n3  File I/O3-1\n3.1 File I/O overview3-3\n3.2open(),read(),write(), andclose()3-8\n3.3 API summary3-20\n3.4 Exercises3-22\n4  Processes4-1\n4.1 Process IDs4-3\n4.2 Process memory layout4-6\n4.3 Command-line arguments4-9\n4.4 The environment list4-12\n4.5 The/procfilesystem4-17\n5  Signals5-1\nDetailed table of contents\n5.1 Overview of signals5-3\n5.2 Signal dispositions5-8\n5.3 Useful signal-related functions5-16\n5.4 Signal handlers5-21\n5.5 Exercises5-25\n5.6 Signal sets, the signal mask, and pending signals5-30\n5.7 API summary5-39\n5.8 Exercises5-41\n5.9 Homework exercises5-45\n5.10 Designing signal handlers5-47\n6  Process Lifecycle6-1\n6.1 Introduction6-3\n6.2 Creating a new process:fork()6-6\n6.3 Exercises6-10\n6.4 Process termination6-13\n6.5 Monitoring child processes6-19\n6.6 Orphans and zombies6-31\n6.7 API summary6-37\n6.8 Exercises6-39\n6.9 TheSIGCHLDsignal6-42\n6.10 Executing programs:execve()6-46\n\nDetailed table of contents\n6.11 Exercises6-55\n6.12 Theexec()library functions6-58\n7  System Call Tracing withstrace7-1\n7.1 Getting started7-3\n7.2 Tracing child processes7-11\n7.3 Exercises7-15\n7.4 Filteringstraceoutput7-17\n7.5 System call tampering7-23\n7.6 Furtherstraceoptions7-29\n8  Wrapup8-1\n8.1 Wrapup8-3\nThis page intentionally blank\nBut, here’s a tech talk you might enjoy:\nDeconstructing Privilege\nPatricia Aas, NDC Oslo 2019\n(Not your average tech talk, but targeted at a technical audience and cleverly delivered in\na technical way)\nhttps://www.youtube.com/watch?v=02gpZuK5gF8\n\nLinux System Programming Essentials\nCourse Introduction\nMichael Kerrisk, man7.org©2025\nAugust 2025\nmtk@man7.org\nOutlineRev: # caf166f4161b\n1  Course Introduction1-1\n1.1 Course overview1-3\n1.2 Course materials and resources1-9\n1.3 Common abbreviations1-13\n1.4 Introductions1-15\n\nOutline\n1  Course Introduction1-1\n1.1 Course overview1-3\n1.2 Course materials and resources1-9\n1.3 Common abbreviations1-13\n1.4 Introductions1-15\nCourse prerequisites\nPrerequisites\n(Good) reading knowledge of C\nCan log in to Linux / UNIX and use basic commands\nKnowledge ofmake(1)is helpful\n(Can do a short tutorial during first practical session for\nthose new tomake)\nAssumptions\nYou are familiar with commonly used parts of standard C\nlibrary\ne.g.,stdioandmallocpackages\nSystem Programming Essentials©2025 M. KerriskCourse Introduction1-4  §1.1\n\nCourse goals\nAimed at programmers building/understanding low-level\napplications\nGain strong understanding of programming API that kernel\npresents to user-space\nSystem calls\nRelevant C library functions\nOther interfaces (e.g.,/proc)\nNecessarily, we sometimes delve into inner workings of kernel\n(But... not an internals course)\nCourse topics\nCourse flyer\nFor more detail, see TOC in course book(s)\nSystem Programming Essentials©2025 M. KerriskCourse Introduction1-5  §1.1\nLab sessions\nLots of lab sessions...\nPair/group work is strongly encouraged!\nUsually gets us through practical sessions faster\n⇒so we can cover more topics\nRead each exercise thoroughlybefore starting\n⇒exercise descriptions often includeimportant hints\nLab sessions arenotinstructor down time...\n⇒One-on-one questions about course material or exercises\nSystem Programming Essentials©2025 M. KerriskCourse Introduction1-6  §1.1\n\nCoding exercises\nFor coding exercises, you can use any suitable programming\nlanguage in which you are proficient\nC/C++ (easiest...)\nGo, D, Rust, & other languages that compile to native\nmachine code\nMost features can also be exercised from scripting languages\nsuch as Python, Ruby, and Perl\nTemplatesolutions are provided for most coding exercises\nFilenames:ex.*.c\nLook for “FIXMEs” to see what parts you must complete\n\"\nYou need to edit correspondingMakefileto add a new\ntarget for the executable\nSolutionswill be mailed out shortly after end of course\nSystem Programming Essentials©2025 M. KerriskCourse Introduction1-7  §1.1\nLab sessions: some thoughts on building code\nMany warnings indicate real problems in the code; fix them\nAnd the “harmless warnings” create noise that hides the\nserious warnings; fix them too\nThis is a good thing:cc -Werror\nTreat all warnings as errors\nhttps://stackoverflow.com/questions/57842756/\nwhy-should-i-always-enable-compiler-warnings\nRather than writing lots of code before first compile, use a\nfrequent edit-save-build cycle to catch compiler errors early\nE.g., run the following in a separate window as you edit:\n$whileinotifywait -q . ;doecho -e'\\n\\n'; make; done\ninotifywaitis provided in theinotify-toolspackage\n(Theechocommand just injects some white space between\neach build)\nSystem Programming Essentials©2025 M. KerriskCourse Introduction1-8  §1.1\n\nOutline\n1  Course Introduction1-1\n1.1 Course overview1-3\n1.2 Course materials and resources1-9\n1.3 Common abbreviations1-13\n1.4 Introductions1-15\nCourse materials\nSlides / course book\nSource code tarball\nLocation sent by email\nUnpacked source code is a Git repository; you can\ncommit/revert changes, etc.\nKerrisk, M.T. 2010.The Linux Programming Interface\n(TLPI), No Starch Press.\nFurther info on TLPI:http://man7.org/tlpi/\nAPI changes since publication:\nhttp://man7.org/tlpi/api_changes/\n(Slides frequently reference TLPI in bottom RHS corner)\nSystem Programming Essentials©2025 M. KerriskCourse Introduction1-10  §1.2\n\nOther resources\nPOSIX.1-2001 / SUSv3:\nhttp://www.unix.org/version3/\nPOSIX.1-2008 / SUSv4:\nhttp://www.unix.org/version4/\nPOSIX.1-2024 / SUSv5:\nhttps://pubs.opengroup.org/onlinepubs/9799919799/\nManual pages\nSection 2: system calls\nSection 3: library functions\nSection 7: overviews\nLatest version online at\nhttp://man7.org/linux/man-pages/\nLatest tarball downloadable at\nhttps://mirrors.edge.kernel.org/pub/linux/docs/man-pages/\nSystem Programming Essentials©2025 M. KerriskCourse Introduction1-11  §1.2\nBooks\nGeneral:\nStevens, W.R., and Rago, S.A. 2013.Advanced Programming in the UNIX\nEnvironment (3rd edition). Addison-Wesley.\nhttp://www.apuebook.com/\nPOSIX threads:\nButenhof, D.R. 1996.Programming with POSIX Threads. Addison-Wesley.\nTCP/IP and network programming:\nFall, K.R. and Stevens, W.R. 2013.TCP/IP Illustrated, Volume 1: The Protocols\n(2nd Edition). Addison-Wesley.\nStevens, W.R., Fenner, B., and Rudoff, A.M. 2004.UNIX Network\nProgramming,Volume 1 (3rd edition): The Sockets Networking API.\nAddison-Wesley.\nhttp://www.unpbook.com/\nStevens, W.R. 1999.UNIX Network Programming, Volume 2 (2nd edition):\nInterprocess Communications. Prentice Hall.\nhttp://www.kohala.com/start/unpv22e/unpv22e.html\nOperating systems:\nTanenbaum, A.S., and Woodhull, A.S. 2006.Operating Systems: Design And\nImplementation (3rd edition). Prentice Hall.\n(The Minix book)\nComer, D. 2015.Operating System Design: The Xinu Approach (2nd edition)\nSystem Programming Essentials©2025 M. KerriskCourse Introduction1-12  §1.2\n\nOutline\n1  Course Introduction1-1\n1.1 Course overview1-3\n1.2 Course materials and resources1-9\n1.3 Common abbreviations1-13\n1.4 Introductions1-15\nCommon abbreviations used in slides\nThe following abbreviations are sometimes used in the slides:\nACL: access control list\nCOW: copy-on-write\nCV: condition variable\nCWD: current working directory\nEA: extended attribute\nEOF: end of file\nFD: file descriptor\nFS: filesystem\nFTM: feature test macro\nGID: group ID\nrGID, eGID, sGID, fsGID\niff: “if and only if”\nIPC: interprocess communication\nKSE: kernel scheduling entity\nMQ: message queue\nMQD: message queue descriptor\nNS: namespace\nOFD: open file description\nPG: process group\nPID: process ID\nPPID: parent process ID\nSHM: shared memory\nSID: session ID\nSEM: semaphore\nSUS: Single UNIX specification\nUID: user ID\nrUID, eUID, sUID, fsUID\nSystem Programming Essentials©2025 M. KerriskCourse Introduction1-14  §1.3\n\nOutline\n1  Course Introduction1-1\n1.1 Course overview1-3\n1.2 Course materials and resources1-9\n1.3 Common abbreviations1-13\n1.4 Introductions1-15\nIntroductions: me\nProgrammer, trainer, writer\nUNIX since 1987, Linux since mid-1990s\nActive contributor to Linux\nAPI review, testing, and documentation\nAPI design and design review\nLots of testing, lots of bug reports, a few kernel patches\nMaintainer of Linuxman-pagesproject (2004-2021)\nDocuments kernel-user-space + C library APIs\nContributor since 2000\nAs maintainer:≈23k commits, 196 releases\nAuthor/coauthor of≈440 manual pages\nKiwi in .de\n(mtk@man7.org, PGP: 4096R/3A35CE5E)\nhttp://linkedin.com/in/mkerrisk\nSystem Programming Essentials©2025 M. KerriskCourse Introduction1-16  §1.4\n\nIntroductions: you\nIn brief:\nWho are you?\nIf virtual: where are you?\nTwo interesting things about you / things you like to do\nwhen you are not in front of a keyboard\nSystem Programming Essentials©2025 M. KerriskCourse Introduction1-17  §1.4\nQuestions policy\nGeneral policy: ask questions any time, in one of the\nfollowing ways:\nOnSlack\nIf online, click the“Raise hand” button\nI’ll usually see it,and I get to see your name as well\nOr out loud\nBut, wait for a quiet point\nAnd if online, please announce your name, since I might not\nbe able to see you\nIn the event that questions slow us down too much, I may\nsay: “batch your questions until nextQuestion penguinslide”\nSystem Programming Essentials©2025 M. KerriskCourse Introduction1-18  §1.4\n\nThis page intentionally blank\nThis page intentionally blank\n\nLinux System Programming Essentials\nFundamental Concepts\nMichael Kerrisk, man7.org©2025\nAugust 2025\nmtk@man7.org\nOutlineRev: # caf166f4161b\n2  Fundamental Concepts2-1\n2.1 Error handling2-3\n2.2 System data types2-10\n2.3 Notes on code examples2-15\n\nOutline\n2  Fundamental Concepts2-1\n2.1 Error handling2-3\n2.2 System data types2-10\n2.3 Notes on code examples2-15\nError handling\nMost system calls and library functions return a status\nindicating success or failure\nOn failure, most system calls:\nReturn –1\nPlace integer value in global variableerrnoto indicate cause\nSome library functions follow same convention\nOften, we’ll omit return values from slides, where they follow\nusual conventions\nCheck manual pages for details\nSystem Programming Essentials©2025 M. KerriskFundamental Concepts2-4  §2.1\n\nError handling\nReturn status shouldalwaysbe tested\n\"\nInspecterrnoonly if result status indicates failure\nAPIs do not reseterrnoto 0 on success\nA successful call may modifyerrno(POSIX allows this)\nE.g., this is wrong:\nfd = open(pathname, O_RDONLY);\nprintf(\"open() has returned\\n\");    // Might modify errno!\nif(fd == -1) {         // Did open() fail?\nperror(\"open\");     // Print message based on'errno'\nexit(EXIT_FAILURE);\n}\nSystem Programming Essentials©2025 M. KerriskFundamental Concepts2-5  §2.1\nerrno\nWhen an API call fails,errnois set to indicate cause\nInteger value, global variable\nIn multithreading environment, each thread has privateerrno\nError numbers inerrnoare > 0\n<errno.h>defines symbolic names for error numbers\n#defineEPERM    1      /* Operation not permitted */\n#defineENOENT   2      /* No such file or directory */\n#defineESRCH    3      /* No such process */\n...\nerrno(1)can be used to search for errors by number or name\nPart ofmoreutilspackage (since 2012)\nSystem Programming Essentials©2025 M. KerriskFundamental Concepts2-6  §2.1\n\nChecking for errors\ncnt = read(fd, buf, numbytes);\nif(cnt==-1) {          /* Was there an error? */\nif(errno==EINTR)\nfprintf(stderr, \"read() was interrupted by a signal\\n\");\nelse if(errno==EBADF)\nfprintf(stderr, \"read() given bad file descriptor\\n\");\nelse{\n/* Some other error occurred */\n}\n}\nSystem Programming Essentials©2025 M. KerriskFundamental Concepts2-7  §2.1\nDisplaying error messages\n#include<stdio.h>\nvoidperror(const char*msg);\nOutputs tostderr:\nmsg+ “: ” + string corresponding to value inerrno\nE.g., iferrnocontainsEBADF,perror(\"close\")would display:\nclose: Bad file descriptor\nSimple error handling:\nfd = open(pathname, flags, mode);\nif(fd == -1) {\nperror(\"open\");\nexit(EXIT_FAILURE);\n}\n(More sophisticated programs might take actions other than\nterminating on syscall error)\nSystem Programming Essentials©2025 M. KerriskFundamental Concepts2-8  §2.1\n\nDisplaying error messages\n#include<string.h>\nchar*strerror(interrnum);\nReturns an error string corresponding to error inerrnum\nSame string as printed byperror()\nUnknown error number?⇒\"Unknown error nnn\"\nOrNULLon some systems\nSystem Programming Essentials©2025 M. KerriskFundamental Concepts2-9  §2.1\nOutline\n2  Fundamental Concepts2-1\n2.1 Error handling2-3\n2.2 System data types2-10\n2.3 Notes on code examples2-15\n\nSystem data types\nVarious system info needs to be represented in C\nProcess IDs, user IDs, file offsets, etc.\nUsing native C data types (e.g.,int,long) in application code\nwould be nonportable; e.g.:\nsizeof(long)might be 4 on one system, but 8 on another\nOne system might useintfor PIDs, while another useslong\nEven on same system, things may change across versions\nE.g., in kernel 2.4, Linux switched from 16 to 32-bit UIDs\n⇒POSIX defines system data types:\nImplementations must suitably define each system data type\nDefined viatypedef; e.g.,typedef int pid_t\nMost types have names suffixed “_t”\nApplications should use these types; e.g.,pid_t mypid;\n⇒will compile to correct types on any conformant system\n[TLPI§3.6.2]\nSystem Programming Essentials©2025 M. KerriskFundamental Concepts2-11  §2.2\nExamples of system data types\nData type\nPOSIX type\nrequirement\nDescription\nuid_tIntegerUser ID\ngid_tIntegerGroup ID\npid_tSigned integerProcess ID\nid_tInteger\nGeneric ID type; can holdpid_t,\nuid_t,gid_t\noff_tSigned integerFile offset or size\nsigset_tInteger or structureSignal set\nsize_tUnsigned integerSize of object (in bytes)\nssize_tSigned integerSize of object or error indication\ntime_tInteger/real-floatingTime in seconds since Epoch\ntimer_tArithmetic typePOSIX timer ID\n(Arithmetic type∈integer or floating type)\nSystem Programming Essentials©2025 M. KerriskFundamental Concepts2-12  §2.2\n\nPrinting system data types\nNeed to take care when passing system data types toprintf()\nExample:pid_tcan beshort,int, orlong\nSuppose we write:\nprintf(\"My PID is: %d\\n\", getpid());\nWorks fine if:\npid_tisint\npid_tisshort(C promotesshortargument toint)\nButwhat ifpid_tislong(andlongis bigger thanint)?\n⇒argument exceeds range understood by format specifier\n(top bytes will be lost)\nSystem Programming Essentials©2025 M. KerriskFundamental Concepts2-13  §2.2\nPrinting system data types\nOn virtually all implementations, most integer system data\ntypes arelongor smaller\n⇒Promote tolongwhen printing system data types\nprintf(\"My PID is: %ld\\n\", (long)getpid());\nMost notable exception:off_tis typicallylong long\nPromote tolong longforprintf()\nprintf(\"Offset is %lld\\n\",\n(longlong)lseek(fd, 0, SEEK_CUR));\nCan also use%zuand%zdforsize_tandssize_t\nC99 hasintmax_t(uintmax_t) with%jd(%ju) specifier\nSolution for all integer types, but not on pre-C99 systems\nMust include<stdint.h>to get these type definitions\nSystem Programming Essentials©2025 M. KerriskFundamental Concepts2-14  §2.2\n\nOutline\n2  Fundamental Concepts2-1\n2.1 Error handling2-3\n2.2 System data types2-10\n2.3 Notes on code examples2-15\nCode examples presented in course\nCode tarball== code from TLPI + further code for course\nExamples on slides edited/excerptedfor brevity\nE.g., error-handling code may be omitted\nSlides always showpathname for full source code\nFull source code always includes error-handling code\nCode license:\nGNU GPL v3 for programs\nGNU Lesser GPL v3 for libraries\nhttp://www.gnu.org/licenses/#GPL\nUnderstanding Open Source and Free Software Licensing,\nA.M. St Laurent, 2004\nOpen Source Licensing: Software Freedom and Intellectual Property Law,\nL. Rosen, 2004\nOpen Source Software: Rechtliche Rahmenbedingungen der Freien\nSoftware, Till Jaeger, 2020\nDroit des logiciels, F. Pellegrini & S. Canevet, 2013\nSystem Programming Essentials©2025 M. KerriskFundamental Concepts2-16  §2.3\n\nExample codelib/subdirectory\nlib/subdirectory contains code of a few functions\ncommonly used in examples\ncamelCasefunction name?\n⇒It’s mine\nSystem Programming Essentials©2025 M. KerriskFundamental Concepts2-17  §2.3\nCommon header file\nMany code examples make use of header filetlpi_hdr.h\nGoal: make code examples a little shorter\ntlpi_hdr.h:\nIncludes a few frequently used header files\nIncludes declarations of some error-handling functions\n[TLPI§3.5.2]\nSystem Programming Essentials©2025 M. KerriskFundamental Concepts2-18  §2.3\n\nError-handling functions used in examples\nCould handle errors as follows:\nfd = open(pathname, flags, mode);\nif(fd == -1) {\nperror(\"open\");\nexit(EXIT_FAILURE);\n}\nVerbose! To make error handling more compact, I define\nsome simple error-handling functions\nSystem Programming Essentials©2025 M. KerriskFundamental Concepts2-19  §2.3\nError-handling functions used in examples\n#include\"tlpi_hdr.h\"\nerrExit(const char*format, ...);\nPrints error message onstderrthat includes:\nSymbolic name forerrnovalue (via some trickery)\nstrerror()description for currenterrnovalue\nText from theprintf()-style message supplied in arguments\nA terminating newline\nTerminates program with exit statusEXIT_FAILURE(1)\nExample:\nif(close(fd) == -1)\nerrExit(\"close (fd=%d)\", fd);\nmight produce:\nERROR [EBADF Bad file descriptor] close (fd=5)\nSystem Programming Essentials©2025 M. KerriskFundamental Concepts2-20  §2.3\n\nError-handling functions used in examples\n#include\"tlpi_hdr.h\"\nerrMsg(const char*format, ...);\nLikeerrExit(), but does not terminate program\n#include\"tlpi_hdr.h\"\nfatal(const char*format, ...);\nDisplays aprintf()-style message + newline\nTerminates program with exit statusEXIT_FAILURE(1)\nSystem Programming Essentials©2025 M. KerriskFundamental Concepts2-21  §2.3\nBuilding the sample code\nYou can manually compile the example programs, but there is\nalso aMakefilein each directory\n⇒Typingmakein source code root directory builds the\nprograms in most subdirectories\nIf you encounter build errors relating to ACLs, capabilities, or\nSELinux, seehttp://man7.org/tlpi/code/faq.html\nPreferred solution is to install the necessary packages:\nDebian, Ubuntu:libcap-dev,libacl1-dev,libreadline-dev\nlibcrypt-dev\nRPM-based systems:libcap-devel,libacl-devel,readline-devel\nlibxcrypt-devel\nSystem Programming Essentials©2025 M. KerriskFundamental Concepts2-22  §2.3\n\nUsing library functions from the sample code\nTo use my library functions in your code:\nIncludetlpi_hdr.hin your C source file\nLocated inlib/subdirectory in source code\nLink against my library,libtlpi.a, located in source\ncode root directory\nTo build library, runmakein the source code root directory or\ninlib/subdirectory\nMethod 1: Place your program in one of “my” directories,\nadd target to correspondingMakefile, and build usingmake\nMethod 2: Manually compile with the following command:\ncc -Isrc-root/lib yourprog.c src-root/libtlpi.a\nsrc-rootmust be replaced with the absolute or relative path\nof source code root directory\nSystem Programming Essentials©2025 M. KerriskFundamental Concepts2-23  §2.3\nThis page intentionally blank\nBut, here’s a tech talk you might enjoy:\nPostmodern strace\nDmitry Levin, FOSDEM 2020\nhttps://www.youtube.com/watch?v=dxOYSGouY-0\n\nLinux System Programming Essentials\nFile I/O\nMichael Kerrisk, man7.org©2025\nAugust 2025\nmtk@man7.org\nOutlineRev: # caf166f4161b\n3  File I/O3-1\n3.1 File I/O overview3-3\n3.2open(),read(),write(), andclose()3-8\n3.3 API summary3-20\n3.4 Exercises3-22\n\nOutline\n3  File I/O3-1\n3.1 File I/O overview3-3\n3.2open(),read(),write(), andclose()3-8\n3.3 API summary3-20\n3.4 Exercises3-22\nFiles\n“On UNIX, everything is a file”\nMore correctly: “everything is a file descriptor”\nNote: the termfilecan be ambiguous:\nAgeneric term, covering disk files, directories, sockets,\nFIFOs, terminals and other devices and so on\nOr specifically, adisk filein a filesystem\nTo clearly distinguish the latter, the termregular fileis\nsometimes used\nSystem Programming Essentials©2025 M. KerriskFile I/O3-4  §3.1\n\nSystem calls versusstdio\nC programs usually usestdiopackage for file I/O\nLibrary functions layered on top of I/O system calls\nSystem callsLibrary functions\nfile descriptor (int)file stream (FILE *)\nopen(),close()fopen(),fclose()\nlseek()fseek(),ftell()\nread()fgets(),fscanf(),fread(). . .\nwrite()fputs(),fprintf(),fwrite(), . . .\n–feof(),ferror()\nWe presume understanding ofstdio;⇒focus on system calls\nSystem Programming Essentials©2025 M. KerriskFile I/O3-5  §3.1\nFile descriptors\nAll I/O is done using file descriptors (FDs)\nnonnegative integer that identifies an open file\nUsed for all types of files\nterminals, regular files, pipes, FIFOs, devices, sockets, ...\n3 FDs are normally available to programs run from shell:\n(POSIX names are defined in<unistd.h>)\nFDPurposePOSIX namestdiostream\n0Standard inputSTDIN_FILENOstdin\n1Standard outputSTDOUT_FILENOstdout\n2Standard errorSTDERR_FILENOstderr\nSystem Programming Essentials©2025 M. KerriskFile I/O3-6  §3.1\n\nKey file I/O system calls\nFour fundamental calls:\nopen(): open a file, optionally creating it if needed\nReturns file descriptor used by remaining calls\nread(): input\nwrite(): output\nclose(): close file descriptor\nSystem Programming Essentials©2025 M. KerriskFile I/O3-7  §3.1\nOutline\n3  File I/O3-1\n3.1 File I/O overview3-3\n3.2open(),read(),write(), andclose()3-8\n3.3 API summary3-20\n3.4 Exercises3-22\n\nopen(): opening a file\n#include<sys/stat.h>\n#include<fcntl.h>\nintopen(const char*pathname,intflags, ... /* mode_t mode */);\nOpens existing file / creates and opens new file\nArguments:\npathnameidentifies file to open\nflagscontrols semantics of call\ne.g., open an existing file vs create a new file\nmodespecifies permissions when creating new file\nReturns: a file descriptor (nonnegative integer)\n(Guaranteed to be lowest available FD)\n[TLPI§4.3]\nSystem Programming Essentials©2025 M. KerriskFile I/O3-9  §3.2\nopen() flagsargument\nflagsis formed by ORing (|) together:\nAccess mode\nSpecify exactly one ofO_RDONLY,O_WRONLY, orO_RDWR\nFile creation flags (bit flags)\nFile status flags (bit flags)\n[TLPI§4.3.1]\nSystem Programming Essentials©2025 M. KerriskFile I/O3-10  §3.2\n\nFile creation flags\nFile creation flags:\nAffect behavior ofopen()call\nCan’t be retrieved or changed\nExamples:\nO_CREAT: create file if it doesn’t exist\nmodeargument must be specified\nWithoutO_CREAT, can open only an existing file (else:\nENOENT)\nO_EXCL: create “exclusively”\nGive an error (EEXIST) if file already exists\nOnly meaningful withO_CREAT\nO_TRUNC: truncate existing file to zero length\nI.e., discard existing file content\nSystem Programming Essentials©2025 M. KerriskFile I/O3-11  §3.2\nFile status flags\nFile status flags:\nAffect semantics of subsequent file I/O\nCan be retrieved and modified usingfcntl()\nExamples:\nO_APPEND: always append writes to end of file\nO_NONBLOCK: nonblocking I/O\nSystem Programming Essentials©2025 M. KerriskFile I/O3-12  §3.2\n\nopen()examples\nOpen existing file for reading:\nfd = open(\"script.txt\", O_RDONLY);\nOpen file for read-write, create if necessary, ensure we are\ncreator:\nfd = open(\"myfile.txt\", O_CREAT | O_EXCL | O_RDWR,\nS_IRUSR | S_IWUSR);       /* rw------- */\nOpen file for writing, creating if necessary:\nfd = open(\"myfile.txt\", O_CREAT | O_WRONLY, S_IRUSR);\nFile opened for writing, but created with only read\npermission!\nSystem Programming Essentials©2025 M. KerriskFile I/O3-13  §3.2\nread(): reading from a file\n#include<unistd.h>\nssize_t read(intfd,void*buffer, size_t count);\nfd: file descriptor\nbuffer: pointer to buffer to store data\ncount: number of bytes to read\n(buffermust be at least this big)\n(ssize_tandsize_tare signed and unsigned integer types)\nReturns:\n> 0: number of bytes read\nMay be <count(e.g., terminalread()gets only one line)\n0: end of file\n–1: error\n\"\nNo terminating null byte is placed at end of buffer\nSystem Programming Essentials©2025 M. KerriskFile I/O3-14  §3.2\n\nwrite(): writing to a file\n#include<unistd.h>\nssize_t write(intfd,const void*buffer, size_t count);\nfd: file descriptor\nbuffer: pointer to data to be written\ncount: number of bytes to write\nReturns:\nNumber of bytes written\nMay be <count(a “partial write”)\n(e.g., write fills device, or insufficient space to write entire\nbuffer to nonblocking socket)\n–1 on error\nSystem Programming Essentials©2025 M. KerriskFile I/O3-15  §3.2\nclose(): closing a file\n#include<unistd.h>\nintclose(intfd);\nfd: file descriptor\nReturns:\n0: success\n–1: error\nReally should check for error!\nAccidentally closing same FD twice\nI.e., detect program logic error\nFilesystem-specific errors\nE.g., NFS commit failures may be reported only atclose()\nNote:close()alwaysreleases FD, even on failure return\nSeeclose(2)manual page\nSystem Programming Essentials©2025 M. KerriskFile I/O3-16  §3.2\n\nExample: copy.c\n$ ./copy old-file new-file\nA simple version ofcp(1)\nSystem Programming Essentials©2025 M. KerriskFile I/O3-17  §3.2\nExample:fileio/copy.c\nAlways remember to handle errors!\n#define BUF_SIZE 1024\nchar buf[BUF_SIZE];\nint infd = open(argv[1], O_RDONLY);\nif (infd == -1) errExit(\"open %s\", argv[1]);\nint flags = O_CREAT | O_WRONLY | O_TRUNC;\nmode_t mode = S_IRUSR | S_IWUSR | S_IRGRP;     /* rw-r----- */\nint outfd = open(argv[2], flags, mode);\nif (outfd == -1) errExit(\"open %s\", argv[2]);\nssize_t nread;\nwhile ((nread = read(infd, buf, BUF_SIZE)) > 0)\nif (write(outfd, buf, nread)!= nread)\nfatal(\"write() returned error or partial write occurred\");\nif (nread == -1) errExit(\"read\");\nif (close(infd)== -1) errExit(\"close\");\nif (close(outfd)== -1) errExit(\"close\");\nSystem Programming Essentials©2025 M. KerriskFile I/O3-18  §3.2\n\nUniversality of I/O\nThe fundamental I/O system calls work on almost all file\ntypes:\n$ ls > mylist\n$ ./copy mylist new        # Regular file\n$ ./copy mylist /dev/tty   # Device\n$ mkfifo f                 # FIFO\n$ cat f &                  # (reads from FIFO)\n$ ./copy mylist f          # (writes to FIFO)\nSystem Programming Essentials©2025 M. KerriskFile I/O3-19  §3.2\nOutline\n3  File I/O3-1\n3.1 File I/O overview3-3\n3.2open(),read(),write(), andclose()3-8\n3.3 API summary3-20\n3.4 Exercises3-22\n\nAPI summary\nintopen(const char*pathname,intflags, ... /* mode_t mode */);\n// Returns a file descriptor\nssize_t read(intfd,void*buffer, size_t count);\n// Returns: # of bytes actually read or 0 for EOF\nssize_t write(intfd,const void*buffer, size_t count);\n// Returns: # of bytes actually written\nintclose(intfd);\nSystem Programming Essentials©2025 M. KerriskFile I/O3-21  §3.3\nOutline\n3  File I/O3-1\n3.1 File I/O overview3-3\n3.2open(),read(),write(), andclose()3-8\n3.3 API summary3-20\n3.4 Exercises3-22\n\nNotes for online practical sessions\nSmall groups inbreakout rooms\nWrite a note into Slack if you have a preferred group\nWe will go faster, if groups collaborateon solving the\nexercise(s)\nYou canshare a screenin your room\nI will circulate regularly between rooms to answer questions\nZoom has an “Ask for help” button...\nKeep an eye on the#generalSlack channel\nPerhaps with further info about exercise;\nOr a note that the exercise merges into a break\nWhen your room has finished, write a message in the Slack\nchannel:“***** Room X has finished *****”\nThen I have an idea of how many people have finished\nSystem Programming Essentials©2025 M. KerriskFile I/O3-23  §3.4\nShared screen etiquette\nIt may help your colleagues if youuse a larger than normal font!\nIn many environments (e.g.,xterm,VS Code), we can adjust the\nfont size withControl+Shift+“+” andControl+“-”\nOr (e.g.,emacs) hold downControlkey and use mouse wheel\nLong shell promptsmake reading your shell session difficult\nUsePS1='$'orPS1='#'\nLow contrastcolor themes are difficult to read; change this if you can\nTurn online numberingin your editor\nInvimuse::set number\nInemacsuse:M-x display-line-numbers-mode <RETURN>\nM-xmeansLeft-Alt+x\nFor collaborative editing,relative line-numbering is evil....\nInvimuse::set nornu\nInemacs, the following should suffice:\nM-: (display-line-numbers-mode) <RETURN>\nM-: (setq display-line-numbers'absolute) <RETURN>\nM-:meansLeft-Alt+Shift+:\nSystem Programming Essentials©2025 M. KerriskFile I/O3-24  §3.4\n\nUsingtmatein in-person practical sessions\nIn order to share an X-term session with others, do the following:\nEnter the commandtmatein an X-term, and you’ll see the following:\n$ tmate\n...\nConnecting to ssh.tmate.io...\nNote: clear your terminal before sharing readonly access\nweb session read only: ...\nsshsessionreadonly: ssh S0mErAnD0m5Tr1Ng@lon1.tmate.io\nweb session: ...\nsshsession:sshS0mEoTheRrAnD0m5Tr1Ng@lon1.tmate.io\nShare last “ssh” string with colleague(s) via Slack or another channel\nOr: \"ssh session read only\" string gives others read-only access\nYour colleagues should paste that string into an X-term...\nNow, you are sharing an X-term session in which anyone can type\nAny \"mate\" can cut the connection to the session with the\n3-character sequence<ENTER>∼.\nTo see above message again:tmate show-messages\nSystem Programming Essentials©2025 M. KerriskFile I/O3-25  §3.4\nExercise notes\nFor many exercises, there are templates for the solutions\nFilenames:ex.*.c\nLook for FIXMEs to see what pieces of code you must add\n\"\nYou will need to edit the correspondingMakefileto add\na new target for the executable\nLook for theEXERCISE_FILES_EXEmacro\n-EXERCISE_FILES_EXE = # ex.prog_a ex.prob_b\n+EXERCISE_FILES_EXE = ex.prog_a # ex.prog_b\nGet amaketutorial now if you need one\nSystem Programming Essentials©2025 M. KerriskFile I/O3-26  §3.4\n\nExercise\nUsingopen(),close(),read(), andwrite(), implement the command\ntee [-a] file([template:fileio/ex.tee.c]). This command\nwrites a copy of its standard input to standard output and tofile. If\nfiledoes not exist, it should be created. Iffilealready exists, it\nshould be truncated to zero length (O_TRUNC). The program should\nsupport the-aoption, which appends (O_APPEND) output to the file if\nit already exists, rather than truncating the file.\nSome hints:\nYou can build../libtlpi.aby doingmakein source code root directory.\nStandard input & output are automatically opened for a process.\nRemember that you will need to add a target in theMakefile!\nAfter first doing some simple command-line testing, test using the unit test in\ntheMakefile:make tee_test.\nWhy does “man open” show the wrong manual page? It finds a page in the\nwrong section first. Try “man 2 open” instead.\nwhile inotifywait -q . ; do echo -e'\\n\\n'; make; done\nYou may need to install theinotify-toolspackage\nCommand-line options can be parsed usinggetopt(3).\nSystem Programming Essentials©2025 M. KerriskFile I/O3-27  §3.4\nThis page intentionally blank\n\nLinux System Programming Essentials\nProcesses\nMichael Kerrisk, man7.org©2025\nAugust 2025\nmtk@man7.org\nOutlineRev: # caf166f4161b\n4  Processes4-1\n4.1 Process IDs4-3\n4.2 Process memory layout4-6\n4.3 Command-line arguments4-9\n4.4 The environment list4-12\n4.5 The/procfilesystem4-17\n\nOutline\n4  Processes4-1\n4.1 Process IDs4-3\n4.2 Process memory layout4-6\n4.3 Command-line arguments4-9\n4.4 The environment list4-12\n4.5 The/procfilesystem4-17\nProcess ID\n#include<unistd.h>\npid_t getpid(void);\nProcess== running instance of a program\nProgram + program loader (kernel)⇒process\nEvery process has a process ID (PID)\npid_t: positive integer that uniquely identifies process\ngetpid()returns callers’s PID\nKernel allocates PIDs using “elevator” algorithm\nWhen elevator reaches top of range, it then cycles, reusing\nPIDs starting at low end of range\nMaximum PID is 32767 on Linux\nAll PID slots used?⇒fork()fails withEAGAIN\nLimit adjustable via/proc/sys/kernel/pid_max(up to\nkernel’sPID_MAX_LIMITconstant, typically 4*1024*1024)\n[TLPI§6.2]\nSystem Programming Essentials©2025 M. KerriskProcesses4-4  §4.1\n\nParent process ID\n#include<unistd.h>\npid_t getppid(void);\nEvery process has a parent\nTypically, process that created this process usingfork()\nParent process is informed when its child terminates\nAll processes on system thus form a tree\nAt root isinit, PID 1, the ancestor of all processes\n“Orphaned” processes are “adopted” byinit\ngetppid()returns PID of caller’s parent process (PPID)\n[TLPI§6.2]\nSystem Programming Essentials©2025 M. KerriskProcesses4-5  §4.1\nOutline\n4  Processes4-1\n4.1 Process IDs4-3\n4.2 Process memory layout4-6\n4.3 Command-line arguments4-9\n4.4 The environment list4-12\n4.5 The/procfilesystem4-17\n\nProcess memory layout\nVirtual memory of a process is divided intosegments:\nText: machine-language instructions\nMarked read-only to prevent self-modification\nMultiple processes can share same code in memory\nInitialized data: global and static variables that are\nexplicitly initialized\nValues read from program file when process is created\nUninitialized data: global and static variables that are not\nexplicitly initialized\nInitialized to zero when process is created\nStack: storage for function local variables and call linkage\ninfo (saved SP and PC registers)\nHeap: an area from which memory can be dynamically\nallocated and deallocated\nmalloc()andfree()\nSystem Programming Essentials©2025 M. KerriskProcesses4-7  §4.2\nProcess memory layout (simplified)\nargv,environ\nStack\n(grows downward)\n(unallocated memory)\nHeap\n(grows upward)\nUninitialized data (bss)\nInitialized data\nTe xt(program code)\nMemory\nmappings\nplaced here\nLowvirtual\naddress\nHigh virtual\naddress\n[TLPI§6.3]\nSystem Programming Essentials©2025 M. KerriskProcesses4-8  §4.2\n\nOutline\n4  Processes4-1\n4.1 Process IDs4-3\n4.2 Process memory layout4-6\n4.3 Command-line arguments4-9\n4.4 The environment list4-12\n4.5 The/procfilesystem4-17\nCommand-line arguments\nCommand-line arguments of a program provided as first two\narguments ofmain()\nConventionally namedargcandargv\nint argc: number of arguments\nchar *argv[]: array of pointers to arguments (strings)\nargv[0]== name used to invoke program\nargv[argc] == NULL\nE.g., for the command,necho hello world:\n[TLPI§6.6]\nSystem Programming Essentials©2025 M. KerriskProcesses4-10  §4.3\n\nprocexec/show_argv.c\nDisplay command-line arguments of program\nintmain(intargc,char*argv[]) {\nprintf(\"Program invoked with:\\n\");\nprintf(\"    argv[0] == %s\\n\\n\", argv[0]);\nprintf(\"Remaining arguments:\\n\");\nfor(intj = 1; ; j++) {\nprintf(\"    argv[%d] = %s\\n\", j, argv[j]);\nif(argv[j] == NULL)\nbreak;\n}\nexit(EXIT_SUCCESS);\n}\nExample run:\n$ ./show_argvabc\nProgram invoked with:\nargv[0]==./show_argv\nRemaining arguments:\nargv[1] = a\nargv[2] = b\nargv[3] = c\nargv[4]=(null)\nSystem Programming Essentials©2025 M. KerriskProcesses4-11  §4.3\nOutline\n4  Processes4-1\n4.1 Process IDs4-3\n4.2 Process memory layout4-6\n4.3 Command-line arguments4-9\n4.4 The environment list4-12\n4.5 The/procfilesystem4-17\n\nEnvironment list (environ)\nEach process has a list ofenvironment variables\nStrings of formname=value\nNew process inherits copy of parent’s environment\nSimple (one-way) interprocess communication\nCommonly used to control behavior of programs\nExamples:\nHOME: user’s home directory (initialized at login)\nPATH: list of directories to search for executable programs\nEDITOR: user’s preferred editor\n[TLPI§6.7]\nSystem Programming Essentials©2025 M. KerriskProcesses4-13  §4.4\nEnvironment list (environ)\nCan create environment variables within shell:\n$ MANWIDTH=72          # Create shell var.\n$ export MANWIDTH      # Turn shell var. into environment var.\n$ man getpid\nOr:export MANWIDTH=72\nAll processes created by shell will inherit definition\nCreating an environment variable for a single command (does\nnot modify shell’s environment):\n$ MANWIDTH=72 man getpid\nTo list all environment variables, useenv(1)orprintenv(1)\nSystem Programming Essentials©2025 M. KerriskProcesses4-14  §4.4\n\nAccessing the environment from a program\nEnvironment list can be accessed via a global variable:\nextern char**environ;\nNULL-terminated array of pointers to strings:\nDisplaying environment:\nfor(char**ep = environ; *ep != NULL; ep++)\nputs(*ep);\nSystem Programming Essentials©2025 M. KerriskProcesses4-15  §4.4\nEnvironment variable APIs\nFetching value of an EV:value = getenv(\"NAME\");\nCreating/modifying an EV:\nputenv(\"NAME=value\");\nsetenv(\"NAME\", \"value\", overwrite);\nRemoving an EV:unsetenv(\"NAME\");\n/proc/PID/environcan be used (with suitable permissions)\nto view environment of another process\nSee manual pages and TLPI§6.7\nSystem Programming Essentials©2025 M. KerriskProcesses4-16  §4.4\n\nOutline\n4  Processes4-1\n4.1 Process IDs4-3\n4.2 Process memory layout4-6\n4.3 Command-line arguments4-9\n4.4 The environment list4-12\n4.5 The/procfilesystem4-17\nThe/procfilesystem\nPseudofilesystem that exposes kernel information via\nfilesystem metaphor\nStructured as a set of subdirectories and files\nproc(5)manual page\nFiles don’t really exist\nCreated on-the-fly when pathnames under/procare\naccessed\nMany files read-only\nSome files are writable⇒can update kernel settings\nNamed “/proc” because earliest implementations (pre-Linux, 1980s) exposed info\nonly about processes\nhttps://en.wikipedia.org/wiki/Procfs\nSystem Programming Essentials©2025 M. KerriskProcesses4-18  §4.5\n\nThe/procfilesystem: examples\n/proc/cmdline: command line used to start kernel\n/proc/cpuinfo: info about CPUs on the system\n/proc/meminfo: info about memory and memory usage\n/proc/modules: info about loaded kernel modules\n/proc/sys/fs/: files and subdirectories with\nfilesystem-related info\n/proc/sys/kernel/: files and subdirectories with various\nreadable/settable kernel parameters\n/proc/sys/net/: files and subdirectories with various\nreadable/settable networking parameters\nSystem Programming Essentials©2025 M. KerriskProcesses4-19  §4.5\n/proc/PID/directories\nOne/proc/PID/subdirectory for each running process\nSubdirectories and files exposing info about process with\ncorresponding PID\nSome files publicly readable, some readable only by process\nowner; a few files writable\nExamples\ncmdline: command line used to start program\ncwd: current working directory\nenviron: environment of process\nfd: directory with info about open file descriptors\nlimits: resource limits\nmaps: mappings in virtual address space\nstatus: (lots of) info about process\nSystem Programming Essentials©2025 M. KerriskProcesses4-20  §4.5\n\nLinux System Programming Essentials\nSignals\nMichael Kerrisk, man7.org©2025\nAugust 2025\nmtk@man7.org\nOutlineRev: # caf166f4161b\n5  Signals5-1\n5.1 Overview of signals5-3\n5.2 Signal dispositions5-8\n5.3 Useful signal-related functions5-16\n5.4 Signal handlers5-21\n5.5 Exercises5-25\n5.6 Signal sets, the signal mask, and pending signals5-30\n5.7 API summary5-39\n5.8 Exercises5-41\n5.9 Homework exercises5-45\n5.10 Designing signal handlers5-47\n\nOutline\n5  Signals5-1\n5.1 Overview of signals5-3\n5.2 Signal dispositions5-8\n5.3 Useful signal-related functions5-16\n5.4 Signal handlers5-21\n5.5 Exercises5-25\n5.6 Signal sets, the signal mask, and pending signals5-30\n5.7 API summary5-39\n5.8 Exercises5-41\n5.9 Homework exercises5-45\n5.10 Designing signal handlers5-47\nSignals are a notification mechanism\nSignal == notification to a process that an event occurred\n“Software interrupts”\nasynchronous: receiver (generally) can’t predict when a\nsignal will occur\nSystem Programming Essentials©2025 M. KerriskSignals5-4  §5.1\n\nSignal types\n64 signals (on Linux)\nEach signal has a unique integer value\nNumbered starting at 1\n\"\nDefined symbolically in<signal.h>:\nNames of formSIGxxx\ne.g., signal 2 isSIGINT(“terminal interrupt”)\nTwo broad categories of signals:\n“Standard” signals (1 to 31)\nMostly for kernel-defined purposes\nRealtime signals (32 to 64)\nExist for user-defined purposes\n[TLPI§20.1]\nSystem Programming Essentials©2025 M. KerriskSignals5-5  §5.1\nSignal generation\nSignals can be sent to a process by:\nThe kernel (the common case)\nAnother process (with suitable permissions)\nkill(pid, sig)and related APIs\nKernel generates signals for various events, e.g.:\nAttempt to access a nonexistent memory address (SIGSEGV)\nTerminalinterruptcharacter (Control-C) was typed (SIGINT)\nChild process terminated (SIGCHLD)\nProcess CPU time limit exceeded (SIGXCPU)\n[TLPI§20.1]\nSystem Programming Essentials©2025 M. KerriskSignals5-6  §5.1\n\nTerminology\nSome terminology:\nA signal isgeneratedwhen an event occurs\nLater, a signal isdeliveredto the process, which then takes\nsome action in response\nBetween generation and delivery, a signal ispending\nWe canblock(delay) delivery of specific signals by adding\nthem to process’ssignal mask\nSignal mask == set of signals whose delivery is blocked\nPending signal is delivered only after it is unblocked\n[TLPI§20.1]\nSystem Programming Essentials©2025 M. KerriskSignals5-7  §5.1\nOutline\n5  Signals5-1\n5.1 Overview of signals5-3\n5.2 Signal dispositions5-8\n5.3 Useful signal-related functions5-16\n5.4 Signal handlers5-21\n5.5 Exercises5-25\n5.6 Signal sets, the signal mask, and pending signals5-30\n5.7 API summary5-39\n5.8 Exercises5-41\n5.9 Homework exercises5-45\n5.10 Designing signal handlers5-47\n\nSignal default actions\nWhen a signal is delivered, a process takes one of these\ndefault actions:\nIgnore: signal is discarded by kernel, has no effect on process\nTerminate: process is terminated (“killed”)\nCore dump + terminate: process produces a core dump\nand is terminated\nCore dump file can be used to examine state of program\ninside a debugger\nSee alsocore(5)manual page\nStop: execution of process is suspended\nContinue: execution of a stopped process is resumed\nDefault action for each signal is signal-specific\n[TLPI§20.2]\nSystem Programming Essentials©2025 M. KerriskSignals5-9  §5.2\nStandard signals and their default actions\nNameDescriptionDefault\nSIGABRTAbort processCore\nSIGALRMReal-time timer expirationTerm\nSIGBUSMemory access errorCore\nSIGCHLDChild stopped or terminatedIgnore\nSIGCONTContinue if stoppedCont\nSIGFPEArithmetic exceptionCore\nSIGHUPHangupTerm\nSIGILLIllegal instructionCore\nSIGINTInterrupt from keyboardTerm\nSIGIOI/O possibleTerm\nSIGKILLSure killTerm\nSIGPIPEBroken pipeTerm\nSIGPROFProfiling timer expiredTerm\nSIGPWRPower about to failTerm\nSIGQUITTerminal quitCore\nSIGSEGVInvalid memory referenceCore\nSIGSTKFLTStack fault on coprocessorTerm\nSIGSTOPSure stopStop\nSIGSYSInvalid system callCore\nSIGTERMTerminate processTerm\nSIGTRAPTrace/breakpoint trapCore\nSIGTSTPTerminal stopStop\nSIGTTINTerminal input from backgroundStop\nSIGTTOUTerminal output from backgroundStop\nSIGURGUrgent data on socketIgnore\nSIGUSR1User-defined signal 1Term\nSIGUSR2User-defined signal 2Term\nSIGVTALRMVirtual timer expiredTerm\nSIGWINCHTerminal window size changedIgnore\nSIGXCPUCPU time limit exceededCore\nSIGXFSZFile size limit exceededCore\nSignal default actions are:\nTerm: terminate the process\nCore: produce core dump and\nterminate the process\nIgnore: ignore the signal\nStop: stop (suspend) the process\nCont: resume process (if stopped)\nSIGKILLandSIGSTOPcan’t be caught,\nblocked, or ignored\nTLPI§20.2\nSystem Programming Essentials©2025 M. KerriskSignals5-10  §5.2\n\nStop and continue signals\nCertain signalsstopa process, freezing its execution\nExamples:\nSIGTSTP: “terminal stop” signal, generated by typing\nControl-Z\nSIGSTOP: “sure stop” signal\nSIGCONTcauses a stopped process to resume execution\nSIGCONTis ignored if process is not stopped\nMost common use of these signals is inshell job control\nSystem Programming Essentials©2025 M. KerriskSignals5-11  §5.2\nChanging a signal’s disposition\nInstead of default, we can change a signal’s disposition to:\nIgnorethe signal\nHandle (“catch”) the signal: execute a user-defined\nfunction upon delivery of the signal\nRevert to thedefault action\nUseful if we earlier changed disposition\nCan’t change disposition toterminateorcore dump +\nterminate\nBut, a signal handler can emulate these behaviors\nCan’t change disposition ofSIGKILLorSIGSTOP(error:\nEINVAL)\nSo, they always kill or stop a process\nSystem Programming Essentials©2025 M. KerriskSignals5-12  §5.2\n\nChanging a signal’s disposition:sigaction()\n#include<signal.h>\nintsigaction(intsig,const structsigaction *act,\nstructsigaction *oldact);\nsigaction()changes (and/or retrieves) disposition of signalsig\nsigactionstructure describes a signal’s disposition\nactpoints to structure specifying new disposition forsig\noldactreturns previous disposition forsig\nCan beNULLif we don’t care\nsigaction(sig, NULL, &oldact)returns current\ndisposition, without changing it\n[TLPI§20.13]\nSystem Programming Essentials©2025 M. KerriskSignals5-13  §5.2\nsigactionstructure\nstructsigaction {\nvoid(*sa_handler)(int);\nsigset_t sa_mask;\nintsa_flags;\nvoid(*sa_restorer)(void);\n};\nsa_handlerspecifies disposition of signal:\nAddress of a signal handler function\nSIG_IGN: ignore signal\nSIG_DFL: revert to default disposition\nsa_mask: signals to block while handler is executing\nField is initialized using macros described insigsetops(3)\nsa_flags: bit mask of flags affecting invocation of handler\nsa_restorer: not for application use\nUsed internally to implement “signal trampoline”\nSystem Programming Essentials©2025 M. KerriskSignals5-14  §5.2\n\nIgnoring a signal (signals/ignore_signal.c)\nintignoreSignal(intsig)\n{\nstructsigaction sa;\nsa.sa_handler = SIG_IGN;\nsa.sa_flags = 0;\nsigemptyset(&sa.sa_mask);\nreturnsigaction(sig, &sa, NULL);\n}\nA “library function” that ignores specified signal\nsa_maskfield is significant only when establishing a signal\nhandler, but for best practice we initialize to sensible value\nSystem Programming Essentials©2025 M. KerriskSignals5-15  §5.2\nOutline\n5  Signals5-1\n5.1 Overview of signals5-3\n5.2 Signal dispositions5-8\n5.3 Useful signal-related functions5-16\n5.4 Signal handlers5-21\n5.5 Exercises5-25\n5.6 Signal sets, the signal mask, and pending signals5-30\n5.7 API summary5-39\n5.8 Exercises5-41\n5.9 Homework exercises5-45\n5.10 Designing signal handlers5-47\n\nDisplaying signal descriptions\n#define_GNU_SOURCE\n#include<string.h>\nchar*strsignal(intsig);\nReturns string describing signalsig\nNSIGconstant is 1 greater than maximum signal number\nDefine_GNU_SOURCEto get definition from<signal.h>\n[TLPI§20.8]\nSystem Programming Essentials©2025 M. KerriskSignals5-17  §5.3\nExample:signals/t_strsignal.c\nintmain(intargc,char*argv[]) {\nfor(intsig = 1; sig < NSIG; sig++)\nprintf(\"%2d: %s\\n\", sig, strsignal(sig));\nexit(EXIT_SUCCESS);\n}\n$ ./t_strsignal\n1: Hangup\n2: Interrupt\n3: Quit\n4: Illegal instruction\n5: Trace/breakpoint trap\n6: Aborted\n7: Bus error\n8: Floating point exception\n9: Killed\n10: User defined signal 1\n11: Segmentation fault\n12: User defined signal 2\n13: Broken pipe\n...\nSystem Programming Essentials©2025 M. KerriskSignals5-18  §5.3\n\nWaiting for a signal:pause()\n#include<unistd.h>\nintpause(void);\nBlocks execution of caller until a signal is caught\nAlways returns –1 witherrnoset toEINTR\n(Standard return for blocking system call that is interrupted\nby a signal handler)\n(See alsosigsuspend(2))\n[TLPI§20.14]\nSystem Programming Essentials©2025 M. KerriskSignals5-19  §5.3\nOther APIs to learn about\nsigprocmask(2): explicitly modify process signal mask to\ncontrol which signals are blocked\nsigpending(2): discover which signals are pending for calling\nprocess\nSystem Programming Essentials©2025 M. KerriskSignals5-20  §5.3\n\nOutline\n5  Signals5-1\n5.1 Overview of signals5-3\n5.2 Signal dispositions5-8\n5.3 Useful signal-related functions5-16\n5.4 Signal handlers5-21\n5.5 Exercises5-25\n5.6 Signal sets, the signal mask, and pending signals5-30\n5.7 API summary5-39\n5.8 Exercises5-41\n5.9 Homework exercises5-45\n5.10 Designing signal handlers5-47\nSignal handlers\nProgrammer-defined function\nCalled with one integer argument: number of signal\n⇒handler installed for multiple signals can differentiate...\nReturnsvoid\nvoid\nmyHandler(intsig)\n{\n/* Actions to be performed when signal is delivered */\n}\n[TLPI§20.4]\nSystem Programming Essentials©2025 M. KerriskSignals5-22  §5.4\n\nSignal handler invocation\nAutomatically invoked by kernel when signal is delivered:\nCan interrupt main program flow at any time\nOn return, execution continues at point of interruption\nSystem Programming Essentials©2025 M. KerriskSignals5-23  §5.4\nExample:signals/ouch_sigaction.c\nPrint “Ouch!” when Control-C is typed at keyboard\n1static voidsigHandler(intsig) {\n2     printf(\"Ouch!\\n\");              /* UNSAFE */\n3 }\n5intmain(intargc,char*argv[]) {\n6structsigaction sa;\n7     sa.sa_flags = 0;                /* No flags */\n8     sa.sa_handler=sigHandler;     /* Handler function */\n9     sigemptyset(&sa.sa_mask);       /* Don't block additional signals\n10                                        during invocation of handler */\n11if(sigaction(SIGINT, &sa, NULL) == -1)\n12         errExit(\"sigaction\");\n14for(;;)\n15         pause();                    /* Wait for a signal */\n16 }\nSystem Programming Essentials©2025 M. KerriskSignals5-24  §5.4\n\nOutline\n5  Signals5-1\n5.1 Overview of signals5-3\n5.2 Signal dispositions5-8\n5.3 Useful signal-related functions5-16\n5.4 Signal handlers5-21\n5.5 Exercises5-25\n5.6 Signal sets, the signal mask, and pending signals5-30\n5.7 API summary5-39\n5.8 Exercises5-41\n5.9 Homework exercises5-45\n5.10 Designing signal handlers5-47\nNotes for online practical sessions\nSmall groups inbreakout rooms\nWrite a note into Slack if you have a preferred group\nWe will go faster, if groups collaborateon solving the\nexercise(s)\nYou canshare a screenin your room\nI will circulate regularly between rooms to answer questions\nZoom has an “Ask for help” button...\nKeep an eye on the#generalSlack channel\nPerhaps with further info about exercise;\nOr a note that the exercise merges into a break\nWhen your room has finished, write a message in the Slack\nchannel:“***** Room X has finished *****”\nThen I have an idea of how many people have finished\nSystem Programming Essentials©2025 M. KerriskSignals5-26  §5.5\n\nShared screen etiquette\nIt may help your colleagues if youuse a larger than normal font!\nIn many environments (e.g.,xterm,VS Code), we can adjust the\nfont size withControl+Shift+“+” andControl+“-”\nOr (e.g.,emacs) hold downControlkey and use mouse wheel\nLong shell promptsmake reading your shell session difficult\nUsePS1='$'orPS1='#'\nLow contrastcolor themes are difficult to read; change this if you can\nTurn online numberingin your editor\nInvimuse::set number\nInemacsuse:M-x display-line-numbers-mode <RETURN>\nM-xmeansLeft-Alt+x\nFor collaborative editing,relative line-numbering is evil....\nInvimuse::set nornu\nInemacs, the following should suffice:\nM-: (display-line-numbers-mode) <RETURN>\nM-: (setq display-line-numbers'absolute) <RETURN>\nM-:meansLeft-Alt+Shift+:\nSystem Programming Essentials©2025 M. KerriskSignals5-27  §5.5\nUsingtmatein in-person practical sessions\nIn order to share an X-term session with others, do the following:\nEnter the commandtmatein an X-term, and you’ll see the following:\n$ tmate\n...\nConnecting to ssh.tmate.io...\nNote: clear your terminal before sharing readonly access\nweb session read only: ...\nsshsessionreadonly: ssh S0mErAnD0m5Tr1Ng@lon1.tmate.io\nweb session: ...\nsshsession:sshS0mEoTheRrAnD0m5Tr1Ng@lon1.tmate.io\nShare last “ssh” string with colleague(s) via Slack or another channel\nOr: \"ssh session read only\" string gives others read-only access\nYour colleagues should paste that string into an X-term...\nNow, you are sharing an X-term session in which anyone can type\nAny \"mate\" can cut the connection to the session with the\n3-character sequence<ENTER>∼.\nTo see above message again:tmate show-messages\nSystem Programming Essentials©2025 M. KerriskSignals5-28  §5.5\n\nExercise\nWhile a signal handler is executing, the signal that caused it\nto be invoked is (by default) temporarily added to the signal\nmask, so that it is blocked from further delivery until the\nsignal handler returns. Consequently, execution of a signal\nhandler can’t be interrupted by a further execution of the\nsame handler. To demonstrate that this is so, modify the\nsignal handler in thesignals/ouch_sigaction.cprogram\nto include the following after the existingprintf()statement:\nsleep(5);\nprintf(\"Bye\\n\");\nBuild and run the program, type control-C once, and then,\nwhile the signal handler is executing, type control-C three\nmore times. What happens? In total, how many times is the\nsignal handler called?\nSystem Programming Essentials©2025 M. KerriskSignals5-29  §5.5\nOutline\n5  Signals5-1\n5.1 Overview of signals5-3\n5.2 Signal dispositions5-8\n5.3 Useful signal-related functions5-16\n5.4 Signal handlers5-21\n5.5 Exercises5-25\n5.6 Signal sets, the signal mask, and pending signals5-30\n5.7 API summary5-39\n5.8 Exercises5-41\n5.9 Homework exercises5-45\n5.10 Designing signal handlers5-47\n\nSignal sets\nVarious signal-related APIs work withsignal sets\nSignal set == data structure that represents multiple signals\nData type:sigset_t\nTypically a bit mask, but not necessarily\n[TLPI§20.9]\nSystem Programming Essentials©2025 M. KerriskSignals5-31  §5.6\nManipulating signal sets\n#include<signal.h>\nintsigemptyset(sigset_t *set);\nintsigfillset(sigset_t *set);\nintsigaddset(sigset_t *set,intsig);\nintsigdelset(sigset_t *set,intsig);\nintsigismember(constsigset_t *set,intsig);\nsigemptyset()initializessetto contain no signals\nsigfillset()initializessetto contain all signals\nWemustinitialize set usingsigemptyset()orsigfillset()\nbefore employing macros below\nUsingmemset()to zero a signal set isnotcorrect\nsigaddset()addssigtoset\nsigdelset()removessigfromset\nsigismember()returns 1 ifsigis inset, 0 if it is not, or –1 on\nerror (e.g.,sigis invalid)\nSystem Programming Essentials©2025 M. KerriskSignals5-32  §5.6\n\nBlocking signals (the signal mask)\nEach process has asignal mask–a set of signals whose\ndelivery is currently blocked\n(In truth: eachthreadhas a signal mask...)\nIf a blocked signal is generated, it remains pending until\nremoved from signal mask\nThe signal mask can be changed in various ways:\nWhile handler is invoked, thesignal that triggered the\nhandleris (temporarily) added to signal mask\nWhile handler is invoked, any signals specified insa_mask\nare (temporarily) added to signal mask\nExplicitly, usingsigprocmask()\nAttempts to blockSIGKILL/SIGSTOPare silently ignored\n[TLPI§20.10]\nSystem Programming Essentials©2025 M. KerriskSignals5-33  §5.6\nsigprocmask()\n#include<signal.h>\nintsigprocmask(inthow,constsigset_t *set, sigset_t *oldset);\nAdds signals to, or removes signals from, caller’s signal mask\n(Typical use: prevent interruption by signal handler while\nupdating a shared data structure)\nhowspecifies change to signal mask:\nSIG_BLOCK:addsignals insetto signal mask\nI.e.,unionwith existing signal mask\nSIG_UNBLOCK:removesignals insetfrom signal mask\nSIG_SETMASK:assignsetto signal mask\nI.e.,overwriteexisting signal mask\n[TLPI§20.10]\nSystem Programming Essentials©2025 M. KerriskSignals5-34  §5.6\n\nsigprocmask()\n#include<signal.h>\nintsigprocmask(inthow,constsigset_t *set, sigset_t *oldset);\noldsetreturns previous signal mask\nCan beNULLif we don’t care\nsigprocmask(how, NULL, &oldset)retrieves current\nmask without changing it\nhowis ignored\n[TLPI§20.10]\nSystem Programming Essentials©2025 M. KerriskSignals5-35  §5.6\nExample: temporarily blocking a signal\nThe following code snippet shows how to temporarily block a\nsignal (SIGINT) while executing a block of code\nsigset_t blocking, prev;\nsigemptyset(&blocking);\nsigaddset(&blocking, SIGINT);\nsigprocmask(SIG_BLOCK, &blocking, &prev);\n/* ... Code to execute with SIGINT blocked ... */\nsigprocmask(SIG_SETMASK, &prev, NULL);\nWe might do this because main program wants to operate on\nglobal variables that signal handle would also access\nSystem Programming Essentials©2025 M. KerriskSignals5-36  §5.6\n\nPending signals\n#include<signal.h>\nintsigpending(sigset_t *set);\nBetween generation and delivery, a signal ispending\nPending state is normally unobservable unless signal is\nexplicitly blocked\nsigpending()returns (inset) the set of signals currently\npending for caller\nWe donotneed to initializesetbefore callingsigpending()\nCan examinesetusingsigismember():\nsigset_t pending;\nsigpending(&pending);\nif(sigismember(&pending, SIGINT))\nprintf(\"SIGINT (%s) is pending\\n\", strsignal(SIGINT));\n[TLPI§20.11]\nSystem Programming Essentials©2025 M. KerriskSignals5-37  §5.6\nSignals are not queued\nThe set of pending (standard) signals is a mask\n⇒If same signal is generated multiple times while blocked, it\nwill be delivered just once\nSystem Programming Essentials©2025 M. KerriskSignals5-38  §5.6\n\nOutline\n5  Signals5-1\n5.1 Overview of signals5-3\n5.2 Signal dispositions5-8\n5.3 Useful signal-related functions5-16\n5.4 Signal handlers5-21\n5.5 Exercises5-25\n5.6 Signal sets, the signal mask, and pending signals5-30\n5.7 API summary5-39\n5.8 Exercises5-41\n5.9 Homework exercises5-45\n5.10 Designing signal handlers5-47\nAPI summary\nintsigaction(intsig,const structsigaction *act,structsigaction *oldact);\n// Change disposition of'sig'to'act'; returning previous\n// disposition in'oldact'\nstructsigaction{\nvoid(*sa_handler)(int);    // Handler address or DIG_IGN or SIG_DFL\nsigset_t   sa_mask;// Signals to be blocked while handler runs\nintsa_flags;\n...\n};\nchar*strsignal(intsig);// Return string describing a signal\nintpause(void);// Pause until interrupted by signal handler\n// Following are for manipulating signal sets (sigset_t):\nintsigemptyset(sigset_t *set);\nintsigfillset(sigset_t *set);\nintsigaddset(sigset_t *set,intsig);\nintsigdelset(sigset_t *set,intsig);\nintsigismember(constsigset_t *set,intsig);\nintsigprocmask(inthow,constsigset_t *set, sigset_t *oldset);\n// Modify the signal mask and return previous mask;\n//'how'can be SIG_BLOCK / SIG_UNBLOCK / SIG_SETMASK\nintsigpending(sigset_t *set);\n// Return set of pending signals in'set'\nSystem Programming Essentials©2025 M. KerriskSignals5-40  §5.7\n\nOutline\n5  Signals5-1\n5.1 Overview of signals5-3\n5.2 Signal dispositions5-8\n5.3 Useful signal-related functions5-16\n5.4 Signal handlers5-21\n5.5 Exercises5-25\n5.6 Signal sets, the signal mask, and pending signals5-30\n5.7 API summary5-39\n5.8 Exercises5-41\n5.9 Homework exercises5-45\n5.10 Designing signal handlers5-47\nExercises\nThe goal of these exercises is to experiment with signal handlers and the use\nof the signal mask to block delivery of signals. A template for both part 1\nand part 2 of the exercise is provided ([template:\nsignals/ex.pending_sig_expt.c])\nHint: don’t confuse the signal mask with thesa_maskfield that is\npassed tosigaction(). The signal mask is a process attribute maintained\ninside the kernel that can be directly modified using calls tosigaction(). The\nsa_maskfield specifies additional signals that should betemporarilyadded\nto the signal mask while a signal handler is executing.\nWrite a program that:\nBlocks all signals exceptSIGINT. This will require the use of\nsigprocmask()(slides 5-35 + 5-36) as well as the APIs for\nmanipulating signal sets (slide 5-32).\nUsessigaction()(slides 5-13, 5-14, and 5-24) to establish a\nSIGINThandler that does nothing but return.\nCallspause()to wait for a signal.\nSystem Programming Essentials©2025 M. KerriskSignals5-42  §5.8\n\nExercises\nAfterpause()returns:\ndetermines the set of pending signals for the process (use\nsigpending(), slide 5-37);\ntests which signals are in that set (usesigismember(),\niterating through all signals in the range1 <= s < NSIG; see\nslide 5-18);\nand prints the descriptions of those signals (strsignal()).\nRun the program and send it various signals (other thanSIGINTand\nsignals that are ignored by default), using either thekillcommand from\nanother terminal (kill -<sig> <pid>), or by typing signal-generating\nkeys from the terminal where you run the program (Control-Z for\nSIGTSTP, Control-\\(or Control-4) forSIGQUIT). Then type Control-C\nto generateSIGINTand inspect the list of pending signals displayed by\nthe program.\n[Exercises continue on following slide]\nSystem Programming Essentials©2025 M. KerriskSignals5-43  §5.8\nExercises\nExtend the program created in the preceding exercise so that:\nJust after installing the handler forSIGINT, the program also\ninstalls a handler forSIGQUIT(generated when the Control-\\ key\nis pressed). The handler should print a message “SIGQUIT\nreceived”, and return.\nAfter displaying the list of pending signals, the program unblocks\nSIGQUITand callspause()once more. (\n\"\nWhichhowvalue\nshould be given tosigprocmask()?)\nWhile the program is blocking signals (i.e., before typing Control-C), try\ntyping Control-\\ multiple times. After Control-C is typed, how many\ntimes does theSIGQUIThandler display its message? Why?\nIf you run the program once more, and then from another terminal send\ntheSIGKILLsignal to the program (kill -KILL <pid>), what\nhappens? Why?\nSystem Programming Essentials©2025 M. KerriskSignals5-44  §5.8\n\nOutline\n5  Signals5-1\n5.1 Overview of signals5-3\n5.2 Signal dispositions5-8\n5.3 Useful signal-related functions5-16\n5.4 Signal handlers5-21\n5.5 Exercises5-25\n5.6 Signal sets, the signal mask, and pending signals5-30\n5.7 API summary5-39\n5.8 Exercises5-41\n5.9 Homework exercises5-45\n5.10 Designing signal handlers5-47\nHomework exercises\nSuppose that a program has blocked a certain signal, and\nthat signal has been generated and is pending for the\nprocess. What do you suppose will happen if the program\nchanges the disposition of the signal to “ignore” (SIG_IGN)?\nWill the signal still be pending? Write a test program to\nverify your answer.\nSystem Programming Essentials©2025 M. KerriskSignals5-46  §5.9\n\nOutline\n5  Signals5-1\n5.1 Overview of signals5-3\n5.2 Signal dispositions5-8\n5.3 Useful signal-related functions5-16\n5.4 Signal handlers5-21\n5.5 Exercises5-25\n5.6 Signal sets, the signal mask, and pending signals5-30\n5.7 API summary5-39\n5.8 Exercises5-41\n5.9 Homework exercises5-45\n5.10 Designing signal handlers5-47\nDesigning signal handlers\nSignal handlers can, in theory, do anything\nBut, complex signal handlers can easily have subtle bugs\n(e.g., race conditions)\nE.g., if main program and signal handler access same global\nvariables\n\"\nReadsignal-safety(7)manual page!\n⇒Design signal handlers to be as simple as possible\nSystem Programming Essentials©2025 M. KerriskSignals5-48  §5.10\n\nDesigning signal handlers\nSome simple signal-handler designs:\nSet a global flag and return\nMain program periodically checks (and clears) flag, and takes\nappropriate action\n(See the discussion ofsig_atomic_tin TLPI§21.1.3)\nSignal handler does some clean-up and terminates process\n(TLPI§21.2)\nSignal handler performs a nonlocal goto to unwind stack\nsigsetjmp()andsiglongjmp()(TLPI§21.2.1)\nE.g., some shells do this when handling signals\nSystem Programming Essentials©2025 M. KerriskSignals5-49  §5.10\nSignals are not queued\nSignals are not queued\nA blocked signal is marked just once as pending, even if\ngenerated multiple times\n⇒One signal may correspond to multiple “events”\nMust design programs that handle signals to allow for this\nExample:\nSIGCHLDis generated for parent when child terminates\nWhileSIGCHLDhandler executes,SIGCHLDis blocked\nSupposetwomore children terminate while handler executes\nOnly oneSIGCHLDsignal will be queued\nSolution:SIGCHLDhandler should loop, checking if multiple\nchildren have terminated\nSystem Programming Essentials©2025 M. KerriskSignals5-50  §5.10\n\nThis page intentionally blank\nThis page intentionally blank\n\nLinux System Programming Essentials\nProcess Lifecycle\nMichael Kerrisk, man7.org©2025\nAugust 2025\nmtk@man7.org\nOutlineRev: # caf166f4161b\n6  Process Lifecycle6-1\n6.1 Introduction6-3\n6.2 Creating a new process:fork()6-6\n6.3 Exercises6-10\n6.4 Process termination6-13\n6.5 Monitoring child processes6-19\n6.6 Orphans and zombies6-31\n6.7 API summary6-37\n6.8 Exercises6-39\n6.9 TheSIGCHLDsignal6-42\n6.10 Executing programs:execve()6-46\n6.11 Exercises6-55\n6.12 Theexec()library functions6-58\n\nOutline\n6  Process Lifecycle6-1\n6.1 Introduction6-3\n6.2 Creating a new process:fork()6-6\n6.3 Exercises6-10\n6.4 Process termination6-13\n6.5 Monitoring child processes6-19\n6.6 Orphans and zombies6-31\n6.7 API summary6-37\n6.8 Exercises6-39\n6.9 TheSIGCHLDsignal6-42\n6.10 Executing programs:execve()6-46\n6.11 Exercises6-55\n6.12 Theexec()library functions6-58\nCreating processes and executing programs\nFour key system calls (and their variants):\nfork(): create a new (“child”) process\nexit(): terminate calling process\nwait(): wait for a child process to terminate\nexecve(): execute a new program in calling process\n[TLPI§24.1]\nSystem Programming Essentials©2025 M. KerriskProcess Lifecycle6-4  §6.1\n\nUsingfork(),execve(),wait(), andexit()together\nParent process\nrunning program A\nfork()\nParent may perform\nother actions here\nwait(&wstatus)\nExecution of\nparent blocks\nChild process\nrunning program A\nexecve(B, ...)\nChild process\nrunning program B\nexit(status)\nMemory of parent\ncopied to child\nKernel unblocks parent\nand deliversSIGCHLD\nChild status\npassed to parent\nSystem Programming Essentials©2025 M. KerriskProcess Lifecycle6-5  §6.1\nOutline\n6  Process Lifecycle6-1\n6.1 Introduction6-3\n6.2 Creating a new process:fork()6-6\n6.3 Exercises6-10\n6.4 Process termination6-13\n6.5 Monitoring child processes6-19\n6.6 Orphans and zombies6-31\n6.7 API summary6-37\n6.8 Exercises6-39\n6.9 TheSIGCHLDsignal6-42\n6.10 Executing programs:execve()6-46\n6.11 Exercises6-55\n6.12 Theexec()library functions6-58\n\nCreating a new process:fork()\n#include<unistd.h>\npid_t fork(void);\nfork()creates a new process (“the child”)\nChild is anear exact duplicate of caller(“the parent”)\nNotionally, memory of parent is duplicated to create child\nIn practice, copy-on-write duplication is used\n⇒Only page tables must be duplicated at time offork()\nTwo processes share same (read-only) text segment\nTwo processes have separate copies of stack, data, and heap\nsegments\n⇒Each process can modify variables without affecting other\nprocess\n[TLPI§24.2]\nSystem Programming Essentials©2025 M. KerriskProcess Lifecycle6-7  §6.2\nReturn value fromfork()\n#include<unistd.h>\npid_t fork(void);\nBothprocesses continue execution by returning fromfork()\nfork()returns different values in parent and child:\nParent:\nOn success: PID of new child (allows parent to track child)\nOn failure: –1\nChild: returns 0\nChild can obtain its own PID usinggetpid()\nChild can obtain PID of parent usinggetppid()\nSystem Programming Essentials©2025 M. KerriskProcess Lifecycle6-8  §6.2\n\nUsingfork()\nCommon idioms for usingfork():\npid_t pid = fork();\nif(pid == -1) {\n/* Handle error */\n}else if(pid == 0) {\n/* Code executed by child */\n}else{\n/* Code executed by parent */\n}\npid_t pid = fork();\nswitch(pid) {\ncase-1:\n/* Handle error */\nbreak;\ncase0:\n/* Code executed by child */\nbreak;\ndefault:\n/* Code executed by parent */\nbreak;\n}\nSystem Programming Essentials©2025 M. KerriskProcess Lifecycle6-9  §6.2\nOutline\n6  Process Lifecycle6-1\n6.1 Introduction6-3\n6.2 Creating a new process:fork()6-6\n6.3 Exercises6-10\n6.4 Process termination6-13\n6.5 Monitoring child processes6-19\n6.6 Orphans and zombies6-31\n6.7 API summary6-37\n6.8 Exercises6-39\n6.9 TheSIGCHLDsignal6-42\n6.10 Executing programs:execve()6-46\n6.11 Exercises6-55\n6.12 Theexec()library functions6-58\n\nExercise\nWrite a program that usesfork()to create a child process\n([template:procexec/ex.fork_var_test.c]). After thefork()call,\nboth the parent and child should display their PIDs (getpid()). Include\ncode to demonstrate that the child process created byfork()can modify\nits copy of a local variable inmain()without affecting the value in the\nparent’s copy of the variable.\nNote: you may find it useful to use thesleep(num-secs)library\nfunction to delay execution of the parent for a few seconds, to ensure\nthat the child has a chance to execute before the parent inspects its\ncopy of the variable.\nProcesses have many attributes. When a new process is created using\nfork(), which of those attributes are inherited by the child and which are\nnot (e.g., are reset to some default)? Here, we explore whether two\nprocess attributes–signal dispositions and alarm timers–are inherited by\na child process.\n[Exercise continues on the next slide]\nSystem Programming Essentials©2025 M. KerriskProcess Lifecycle6-11  §6.3\nExercise\nWrite a program ([template:procexec/ex.inherit_alarm.c]) that\nperforms the following steps in order to determine if a child process\ninherits signal dispositions and alarm timers from the parent:\nEstablishes aSIGALRMhandler that prints the process’s PID.\nStarts an alarm timer that expires after two seconds. Do this using\nthe callalarm(2). When the timer expires, it will notify by sending\naSIGALRMsignal to the process.\nCreates a child process usingfork().\nAfter thefork(), the child fetches the disposition of theSIGALRM\nsignal (sigaction()) and tests whether thesa_handlerfield in the\nreturned structure is the address of the signal handler\nBoth processes then loop 5 times, sleeping for half a second (use\nusleep()) and displaying the process PID. Which of the processes\nreceives aSIGALRMsignal?\nSystem Programming Essentials©2025 M. KerriskProcess Lifecycle6-12  §6.3\n\nOutline\n6  Process Lifecycle6-1\n6.1 Introduction6-3\n6.2 Creating a new process:fork()6-6\n6.3 Exercises6-10\n6.4 Process termination6-13\n6.5 Monitoring child processes6-19\n6.6 Orphans and zombies6-31\n6.7 API summary6-37\n6.8 Exercises6-39\n6.9 TheSIGCHLDsignal6-42\n6.10 Executing programs:execve()6-46\n6.11 Exercises6-55\n6.12 Theexec()library functions6-58\nTerminating a process\nA process can terminate itself using two APIs:\n_exit(2)(system call)\nexit(3)(library function)\n[TLPI§25.1]\nSystem Programming Essentials©2025 M. KerriskProcess Lifecycle6-14  §6.4\n\nTerminating a process with_exit(2)\n#include<unistd.h>\nvoid_exit(intstatus);\n_exit()terminates the calling process\nAKAnormal termination\nabnormal termination== killed by a signal\n(In truth: on Linux,_exit()is a wrapper for Linux-specificexit_group(2),\nwhich terminates all threads in a process)\nSystem Programming Essentials©2025 M. KerriskProcess Lifecycle6-15  §6.4\nProcess exit status\n#include<unistd.h>\nvoid_exit(intstatus);\nLeast significant 8 bits ofstatusdefineexit status\nRemaining bits ignored\n0 == success\nnonzero == failure\nPOSIX specifies two constants:\n#defineEXIT_SUCCESS 0\n#defineEXIT_FAILURE 1\nSystem Programming Essentials©2025 M. KerriskProcess Lifecycle6-16  §6.4\n\nTerminating a process withexit(3)\nMost programs employexit(3), rather than_exit(2)\n#include<stdlib.h>\nvoidexit(intstatus);\nTheexit(3)library function:\nCalls exit handlers registered by process (TLPI§25.3)\nExit handler == callback function automatically called at\nnormal process termination\natexit(3),on_exit(3)\nFlushesstdiobuffers\nCalls:_exit(status)\n(If we call_exit()directly, then exit handlers arenotcalled\nandstdiobuffers arenotflushed)\nreturn ninsidemain()is equivalent toexit(n)\nSystem Programming Essentials©2025 M. KerriskProcess Lifecycle6-17  §6.4\nProcess teardown\nAs part of process termination (normal or abnormal), the kernel\nperforms various clean-ups:\nAll openfile descriptorsare closed\nAssociatedfile locksare released\nOpenPOSIX IPC objectsare closed (message queues,\nsemaphores, shared memory)\nMemory mappingsare unmapped\nMemory locksare removed\nSystem V shared memory segmentsare detached\nAnd more...\n[TLPI§25.2]\nSystem Programming Essentials©2025 M. KerriskProcess Lifecycle6-18  §6.4\n\nOutline\n6  Process Lifecycle6-1\n6.1 Introduction6-3\n6.2 Creating a new process:fork()6-6\n6.3 Exercises6-10\n6.4 Process termination6-13\n6.5 Monitoring child processes6-19\n6.6 Orphans and zombies6-31\n6.7 API summary6-37\n6.8 Exercises6-39\n6.9 TheSIGCHLDsignal6-42\n6.10 Executing programs:execve()6-46\n6.11 Exercises6-55\n6.12 Theexec()library functions6-58\nOverview\nParent processes can use the “wait” family of APIs to\nmonitor state change events in child processes:\nTermination\nStop (because of a signal)\nContinue (afterSIGCONTsignal)\nParent can obtain various info about state changes:\nExit status of process\nWhat signal stopped or killed process\nWhether process produced a core dump before terminating\nFor historical reasons, there are multiple “wait” functions\nSystem Programming Essentials©2025 M. KerriskProcess Lifecycle6-20  §6.5\n\nWaiting for children withwaitpid()\n#include<sys/wait.h>\npid_t waitpid(pid_t pid,int*wstatus,intoptions);\nwaitpid()waits for a child process to change state\nNo child has changed state⇒call blocks\nChild has already changed state⇒call returns immediately\nwstatusargument returnswait statusvalue that describes\nchild state transition\nwstatuscan beNULL, if we don’t need this info\n(More details later)\nReturn value:\nOn success: PID of child whose status is being reported\nOn error, –1\nNo more children?⇒errnoset toECHILD\n[TLPI§26.1.2]\nSystem Programming Essentials©2025 M. KerriskProcess Lifecycle6-21  §6.5\nWaiting for children withwaitpid()\n#include<sys/wait.h>\npid_t waitpid(pid_t pid,int*wstatus,intoptions);\npidspecifies which child(ren) to wait for:\npid == –1:anychild of caller\npid > 0: child whosePIDequalspid\n(plus other possibilities, as documented in manual page)\nSystem Programming Essentials©2025 M. KerriskProcess Lifecycle6-22  §6.5\n\nWaiting for children withwaitpid()\n#include<sys/wait.h>\npid_t waitpid(pid_t pid,int*wstatus,intoptions);\nBy default,waitpid()reports onlyterminatedchildren\nTheoptionsbit mask can specify additional state changes to\nreport:\nWUNTRACED: reportstoppedchildren\nWCONTINUED: report stopped children that havecontinued\nSpecifyingWNOHANGinoptionscausesnonblockingwait\nIf no children have changed state,waitpid()returns\nimmediately, with return value of 0\nSystem Programming Essentials©2025 M. KerriskProcess Lifecycle6-23  §6.5\nwaitpid()example\nWait for all children to terminate, and report their PIDs:\nfor(;;) {\nchildPid = waitpid(-1, NULL, 0);\nif(childPid == -1) {\nif(errno == ECHILD) {\nprintf(\"No more children!\\n\");\nbreak;\n}else{            /* Unexpected error */\nerrExit(\"waitpid\");\n}\n}\nprintf(\"waitpid() returned PID %ld\\n\", (long) childPid);\n}\nSystem Programming Essentials©2025 M. KerriskProcess Lifecycle6-24  §6.5\n\nThe wait status value\nwstatusdistinguishes 4 types of event:\nChildterminated via_exit(), specifying anexit status\nChild waskilled by a signal\nChild wasstopped by a signal\nChild wascontinued by a signal\nSystem Programming Essentials©2025 M. KerriskProcess Lifecycle6-25  §6.5\nThe wait status value\n16 lowest bits ofwstatusreturned bywaitpid()encode status in\nsuch a way that the 4 cases can be distinguished:\n(Encoding is an implementation detail we don’t really need to care about)\nSystem Programming Essentials©2025 M. KerriskProcess Lifecycle6-26  §6.5\n\nDissecting the wait status\n<sys/wait.h>defines macros for dissecting a wait status\nOnly one of the headline macros in this list will return true:\nWIFEXITED(wstatus): true if child exited normally\nWEXITSTATUS(wstatus)returns exit status of child\nWIFSIGNALED(wstatus): true if child was killed by signal\nWTERMSIG(wstatus)returns number of killing signal\nWCOREDUMP(wstatus)returns true if child dumped core\nWIFSTOPPED(wstatus): true if child was stopped by signal\nWSTOPSIG(wstatus)returns number of stopping signal\nWIFCONTINUED(wstatus): true if child was resumed by"
    },
    {
      "title": "SIGCONT",
      "text": "The subordinate macros may be used only if the\ncorresponding headline macro tests true\nSystem Programming Essentials©2025 M. KerriskProcess Lifecycle6-27  §6.5\nExample:procexec/print_wait_status.c\nDisplay wait status value in human-readable form\nvoidprintWaitStatus(const char*msg,intstatus) {\nif(msg != NULL)\nprintf(\"%s\", msg);\nif(WIFEXITED(status)) {\nprintf(\"child exited, status=%d\\n\", WEXITSTATUS(status));\n}else if(WIFSIGNALED(status)) {\nprintf(\"child killed by signal %d (%s)\",\nWTERMSIG(status), strsignal(WTERMSIG(status)));\nif(WCOREDUMP(status))\nprintf(\" (core dumped)\");\nprintf(\"\\n\");\n}else if(WIFSTOPPED(status)) {\nprintf(\"child stopped by signal %d (%s)\\n\",\nWSTOPSIG(status), strsignal(WSTOPSIG(status)));\n}else if(WIFCONTINUED(status))\nprintf(\"child continued\\n\");\n}\nSystem Programming Essentials©2025 M. KerriskProcess Lifecycle6-28  §6.5\n\nAn older wait API:wait()\n#include<sys/wait.h>\npid_t wait(int*wstatus);\nThe original “wait” API\nwait(&wstatus)==waitpid(-1, &wstatus, 0)\nStill commonly used to handle the simple, common case:\nwait for any child to terminate\nSystem Programming Essentials©2025 M. KerriskProcess Lifecycle6-29  §6.5\nAn newer wait API:waitid()\n#include<sys/wait.h>\nintwaitid(idtype_t idtype, id_t id, siginfo_t *infop,intoptions);\nSimilar towaitpid(), but provides additional functionality,\nincluding:\nIndependently choose which events (termination / stopped /\ncontinued) to wait on\nwaitpid()always waits for at least termination events\nWait via PID file descriptor\nSystem Programming Essentials©2025 M. KerriskProcess Lifecycle6-30  §6.5\n\nOutline\n6  Process Lifecycle6-1\n6.1 Introduction6-3\n6.2 Creating a new process:fork()6-6\n6.3 Exercises6-10\n6.4 Process termination6-13\n6.5 Monitoring child processes6-19\n6.6 Orphans and zombies6-31\n6.7 API summary6-37\n6.8 Exercises6-39\n6.9 TheSIGCHLDsignal6-42\n6.10 Executing programs:execve()6-46\n6.11 Exercises6-55\n6.12 Theexec()library functions6-58\nOrphans\nAnorphanis a process that lives longer than its parent\nOrphaned processes areadopted byinit\ninitwaits for its adopted childrenwhen they terminate\nAfter orphan is adopted,getppid()returns PID ofinit\nConventionally,inithas PID 1\nOn systems where theinitsystem issystemd, then,\ndepending on the configuration, things are different:\nA helper process (PID != 1) becomes parent of orphaned\nchildren\nWhen run with the--useroption,systemdorganizes all\nprocesses in the user’s session into a subtree with such a\nsubreaper\nSee discussion ofPR_SET_CHILD_SUBREAPERinprctl(2)\n[TLPI§26.2]\nSystem Programming Essentials©2025 M. KerriskProcess Lifecycle6-32  §6.6\n\nZombies\nSuppose achild terminates before parent waitsfor it\nParent must still be able to collect status later\n⇒Child becomes azombie:\nMost process resources are recycled\nA process slot is retained\nPID, status, and resource usage statistics\nZombie is removed when parent does a “wait”\n[TLPI§26.2]\nSystem Programming Essentials©2025 M. KerriskProcess Lifecycle6-33  §6.6\nCreating a zombie:procexec/zombie.c\nUsage:zombie [num-zombies [sleep-secs]]\n1intmain(intargc,char*argv[]) {\n2intnzombies =  (argc > 1) ? atoi(argv[1]) : 1;\n3intsleepSecs = (argc > 2) ? atoi(argv[2]) : 0;\n4printf(\"Parent (PID %ld)\\n\", (long) getpid());\n6for(intj = 0; j < nzombies; j++) {\n7switch(fork()) {\n8case-1:\n9errExit(\"fork-%d\", j);\n10case0:/* Child: exits to become zombie */\n11printf(\"Child  (PID %ld) exiting\\n\", (long) getpid());\n12if(sleepSecs > 0);\n13sleep(sleepSecs);\n14exit(EXIT_SUCCESS);\n15default:/* Parent continues in loop */\n16break;\n17}\n18}\n19sleep(3600);/* Children are zombies during this time */\n20while(wait(NULL) > 0)/* Reap zombie children */\n21continue;\n22exit(EXIT_SUCCESS);\n23 }\nCreate one or more zombie child processes\nSystem Programming Essentials©2025 M. KerriskProcess Lifecycle6-34  §6.6\n\nCreating a zombie:procexec/zombie.c\n1 $ ./zombie &\n2 [1] 23425\n3 Parent (PID 23425)\n4 Child  (PID 23427) exiting\n5 $ ps -C zombie\n6   PID TTY          TIME CMD\n7 23425 pts/1    00:00:00 zombie\n8 23427 pts/1    00:00:00 zombie <defunct>\n9 $ kill-KILL23427\n10 $ ps -C zombie\n11   PID TTY          TIME CMD\n12 23425 pts/1    00:00:00 zombie\n13 23427 pts/1    00:00:00 zombie <defunct>\nZombies can’t be killedby signals!\n(Since parent must still be able to “wait”)\nEven silver bullets (SIGKILL) don’t work\nSystem Programming Essentials©2025 M. KerriskProcess Lifecycle6-35  §6.6\nReap your zombies\nZombie may live for ever, if parent fails to “wait” on it\nOr until parent is killed, so zombie is adopted byinit\nLong-lived processes that create children must ensure\nthat zombies are “reaped”(“waited” for)\nShells, network servers, ...\nSystem Programming Essentials©2025 M. KerriskProcess Lifecycle6-36  §6.6\n\nOutline\n6  Process Lifecycle6-1\n6.1 Introduction6-3\n6.2 Creating a new process:fork()6-6\n6.3 Exercises6-10\n6.4 Process termination6-13\n6.5 Monitoring child processes6-19\n6.6 Orphans and zombies6-31\n6.7 API summary6-37\n6.8 Exercises6-39\n6.9 TheSIGCHLDsignal6-42\n6.10 Executing programs:execve()6-46\n6.11 Exercises6-55\n6.12 Theexec()library functions6-58\nAPI summary\npid_t fork(void);// Create a child process; returns\n// PID of child in parent, and 0 in child\nvoid_exit(intstatus);// Terminate process\nvoidexit(intstatus);// Call exit handlers, flush stdio, and\n// terminate process\n// Wait for (and return PID of) a child process:\npid_t waitpid(pid_t pid,int*wstatus,intoptions);\npid_t wait(int*wstatus);\n// Setting up handler for SIGCHLD:\nstructsigaction sa;\nsa.sa_handler = func;// Address of signal handler\nsa.sa_flags = 0;// Or possibly SA_RESTART\nsigemptyset(&sa.sa_mask);// Assuming we don't need to block any other\n// signals while handler runs\nsigaction(SIGCHLD, &sa, NULL);\nSystem Programming Essentials©2025 M. KerriskProcess Lifecycle6-38  §6.7\n\nOutline\n6  Process Lifecycle6-1\n6.1 Introduction6-3\n6.2 Creating a new process:fork()6-6\n6.3 Exercises6-10\n6.4 Process termination6-13\n6.5 Monitoring child processes6-19\n6.6 Orphans and zombies6-31\n6.7 API summary6-37\n6.8 Exercises6-39\n6.9 TheSIGCHLDsignal6-42\n6.10 Executing programs:execve()6-46\n6.11 Exercises6-55\n6.12 Theexec()library functions6-58\nExercise\nSuppose that we have three processes related as grandparent (A),\nparent (B), and child (C), and that the parent exits after a few seconds,\nbut the grandparent doesnotimmediately perform await()after the\nparent exits, with the result that the parent becomes a zombie, as in\nthe following diagram.\nA\nfork()\nB\nfork()\nsleep(3)\nexit()1\nC\nsleep(6)\nwaitpid(B)2\nSystem Programming Essentials©2025 M. KerriskProcess Lifecycle6-40  §6.8\n\nExercise\nWhen do you expect the child (C) to be adopted byinit(so thatgetppid()in the\nchild returns 1): after the parent (B) terminates or after the grandparent (A) does a\nwait()? In other words, is the child adopted at point 1 or point 2 in the diagram?\nWrite a program, [(minimal) template:procexec/ex.zombie_parent.c], to verify\nthe answer.\nNote the following points:\nFor a reminder of the usage offork(), see slide 6-9.\nYou will need to use tosleep()in various parts of the program:\nThe child (C) could loop 10 times, displaying the value returned by\ngetppid()and sleeping for 1 second on each loop iteration.\nThe parent (B) sleeps for 3 seconds before terminating.\nThe grandparent (A) sleeps for 6 seconds before callingwaitpid()on the\nPID of the parent (B).\nDepending on your distribution (e.g., if you have asystemd-based system\nwhere the--userflag is employed), you may find that the orphaned child is\nreparented to a process other than PID 1. Find out what program is running in\nthat process, by using the commandps <pid>.\nSystem Programming Essentials©2025 M. KerriskProcess Lifecycle6-41  §6.8\nOutline\n6  Process Lifecycle6-1\n6.1 Introduction6-3\n6.2 Creating a new process:fork()6-6\n6.3 Exercises6-10\n6.4 Process termination6-13\n6.5 Monitoring child processes6-19\n6.6 Orphans and zombies6-31\n6.7 API summary6-37\n6.8 Exercises6-39\n6.9 TheSIGCHLDsignal6-42\n6.10 Executing programs:execve()6-46\n6.11 Exercises6-55\n6.12 Theexec()library functions6-58\n\nTheSIGCHLDsignal\nSIGCHLDis generated for a parent when a child terminates\nIgnored by default\nCatchingSIGCHLDallows us to be asynchronously notified of\nchild’s termination\nCan be more convenient than synchronous or nonblocking\nwaitpid()calls\nWithinSIGCHLDhandler, we “wait” to reap zombie child\n[TLPI§26.3]\nSystem Programming Essentials©2025 M. KerriskProcess Lifecycle6-43  §6.9\nASIGCHLDhandler\nvoidgrimReaper(intsig) {\nintsavedErrno = errno;\nwhile(waitpid(-1, NULL, WNOHANG) > 0)\ncontinue;\nerrno = savedErrno;\n}\nEachwaitpid()call reaps one terminated child\nwhileloop handles possibility that multiple children terminated\nwhileSIGCHLDwas blocked\ne.g., during earlier invocation of handler\nWNOHANG: don’t block if there are no more terminated children\nLoop terminates whenwaitpid()returns:\n0, meaning no moreterminatedchildren\n–1, probably witherrno == ECHILD, meaning no more children\nSave and restoreerrno, so that handler is reentrant (TLPI p427)\nSystem Programming Essentials©2025 M. KerriskProcess Lifecycle6-44  §6.9\n\nSIGCHLDfor stopped and continued children\nSIGCHLDis also generated when a child stops or continues\nTo prevent this, specifySA_NOCLDSTOPinsa_flagswhen\nestablishingSIGCHLDhandler withsigaction()\n[TLPI§26.3.2]\nSystem Programming Essentials©2025 M. KerriskProcess Lifecycle6-45  §6.9\nOutline\n6  Process Lifecycle6-1\n6.1 Introduction6-3\n6.2 Creating a new process:fork()6-6\n6.3 Exercises6-10\n6.4 Process termination6-13\n6.5 Monitoring child processes6-19\n6.6 Orphans and zombies6-31\n6.7 API summary6-37\n6.8 Exercises6-39\n6.9 TheSIGCHLDsignal6-42\n6.10 Executing programs:execve()6-46\n6.11 Exercises6-55\n6.12 Theexec()library functions6-58\n\nExecuting a new program\nexecve()loads a new program into calling process’s memory\nOld program, stack, data, and heap are discarded\nAfter executing run-time start-up code, execution commences\nin new program’smain()\nVarious functions layered on top ofexecve():\nProvide variations on functionality ofexecve()\nCollectively termed “exec()”\nSeeexec(3)manual page\n[TLPI§27.1]\nSystem Programming Essentials©2025 M. KerriskProcess Lifecycle6-47  §6.10\nExecuting a new program withexecve()\n#include<unistd.h>\nintexecve(const char*pathname,char*constargv[],\nchar*constenvp[]);\nexecve()loads program atpathnameinto caller’s memory\npathnameis an absolute or relative pathname\nSystem Programming Essentials©2025 M. KerriskProcess Lifecycle6-48  §6.10\n\nExecuting a new program withexecve()\n#include<unistd.h>\nintexecve(const char*pathname,char*constargv[],\nchar*constenvp[]);\nargvspecifies command-line arguments for new program\nDefinesargvargument formain()in new program\nNULL-terminated array of pointers to strings\nargv[0]is command name\nTypically, same as (basename part of)pathname\nProgram can vary its behavior, depending on value ofargv[0]\n(e.g.,busybox)\nSee example programs\nprocexec/launch_shell.c(“-” inargv[0][0]when execing\na shell triggers “login shell” behavior)\nprocexec/execve_argv_expt.c\nSystem Programming Essentials©2025 M. KerriskProcess Lifecycle6-49  §6.10\nExecuting a new program withexecve()\n#include<unistd.h>\nintexecve(const char*pathname,char*constargv[],\nchar*constenvp[]);\nenvpspecifies environment list for new program\nDefinesenvironin new program\nNULL-terminated array of pointers to strings\nSystem Programming Essentials©2025 M. KerriskProcess Lifecycle6-50  §6.10\n\nExecuting a new program withexecve()\n#include<unistd.h>\nintexecve(const char*pathname,char*constargv[],\nchar*constenvp[]);\nSuccessfulexecve()does not return\nIfexecve()returns, it failed; no need to check return value:\nexecve(pathname, argv, envp);\nperror(\"execve\");\nexit(EXIT_FAILURE);\nSystem Programming Essentials©2025 M. KerriskProcess Lifecycle6-51  §6.10\nExample:procexec/exec_status.c\n./exec_status command [args...]\nCreate a child process\nChild executescommandwith supplied command-line\narguments\nParent waits for child to terminate, and reports wait status\nSystem Programming Essentials©2025 M. KerriskProcess Lifecycle6-52  §6.10\n\nExample:procexec/exec_status.c\n1extern char**environ;\n2intmain(intargc,char*argv[]) {\n3     pid_t childPid, wpid;\n4intwstatus;\n5     ...\n6switch(childPid=fork()) {\n7case-1: errExit(\"fork\");\n9case0:     /*Child*/\n10         printf(\"PID of child: %ld\\n\", (long) getpid());\n11char**nextArgv=&argv[1];         // argv for next program\n12char*progName=nextArgv[0];\n13         execve(progName,nextArgv,environ);\n14         errExit(\"execve\");\n16default:    /*Parent*/\n17         wpid=waitpid(childPid,&wstatus,0);\n18if(wpid == -1) errExit(\"waitpid\");\n19         printf(\"Wait returned PID %ld\\n\", (long) wpid);\n20         printWaitStatus(\"\",wstatus);\n21     }\n22     exit(EXIT_SUCCESS);\n23 }\nSystem Programming Essentials©2025 M. KerriskProcess Lifecycle6-53  §6.10\nExample:procexec/exec_status.c\n1 $ ./exec_status/bin/date\n2 PID of child: 4703\n3 Thu Oct 24 13:48:44 NZDT 2013\n4 Wait returned PID 4703\n5         childexited,status=0\n6 $ ./exec_status/bin/sleep60&\n7 [1] 4771\n8 PID of child: 4773\n9 $ kill4773\n10 Wait returned PID 4773\n11         childkilledbysignal15(Terminated)\n12 [1]+  Done          ./exec_status /bin/sleep 60\nSystem Programming Essentials©2025 M. KerriskProcess Lifecycle6-54  §6.10\n\nOutline\n6  Process Lifecycle6-1\n6.1 Introduction6-3\n6.2 Creating a new process:fork()6-6\n6.3 Exercises6-10\n6.4 Process termination6-13\n6.5 Monitoring child processes6-19\n6.6 Orphans and zombies6-31\n6.7 API summary6-37\n6.8 Exercises6-39\n6.9 TheSIGCHLDsignal6-42\n6.10 Executing programs:execve()6-46\n6.11 Exercises6-55\n6.12 Theexec()library functions6-58\nExercise\nWrite a simple shell program. The program should loop, continuously reading shell\ncommands from standard input. Each input line consists of a set of white-space\ndelimited words that are a command and its arguments. Each command should be\nexecuted in a new child process (fork()) usingexecve(). The parent process (the\n“shell”) should wait on each child and display its wait status (you can use the\nsuppliedprintWaitStatus()function). [template:procexec/ex.simple_shell.c]\nSome hints:\nThe space-delimited words in the input line need to be broken down into a set\nof null-terminated strings pointed to by anargv-style array, and that array\nmust end with aNULLpointer. Thestrtok(3)library function simplifies this\ntask. (This task is already performed by code in the template.)\nBecauseexecve()is used, you will need to type the full pathname when\nentering commands to your shell\nAs a first test of you shell, try executing the following program (which is in the same\ndirectory):\n./show_argv a b c\nFun facts: the source code ofbashis around 180k lines (dashis around 20k lines)\nSystem Programming Essentials©2025 M. KerriskProcess Lifecycle6-56  §6.11\n\nExercise\nWrite a program, ([template:procexec/ex.exec_self_pid.c]) that verifies that an\nexec does not change a process’s PID.\nThe program should perform the following steps:\nPrint the process’s PID.\nIfargcis 2, the program exits.\nOtherwise, the program usesexecl()to re-execute itself with an\nadditional command-line argument (any string), so thatargcwill be 2.\nTest the program by running it with no arguments (i.e.,argcis 1).\nWrite a program ([template:procexec/ex.make_link.c]) that takes 2 arguments:\nmake_link target linkpath\nIf invoked with the nameslink, it creates a symbolic link (symlink()) using these\npathnames, otherwise it creates a hard link (link()). After compiling, create two hard\nlinks to the executable, with the nameshlinkandslink. Verify that when run with\nthe namehlink, the program creates hard links, while when run with the nameslink,\nit creates symbolic links.\nHint:\nYou will find thebasename()andstrcmp()functions useful when inspecting\nthe program name inargv[0].\nSystem Programming Essentials©2025 M. KerriskProcess Lifecycle6-57  §6.11\nOutline\n6  Process Lifecycle6-1\n6.1 Introduction6-3\n6.2 Creating a new process:fork()6-6\n6.3 Exercises6-10\n6.4 Process termination6-13\n6.5 Monitoring child processes6-19\n6.6 Orphans and zombies6-31\n6.7 API summary6-37\n6.8 Exercises6-39\n6.9 TheSIGCHLDsignal6-42\n6.10 Executing programs:execve()6-46\n6.11 Exercises6-55\n6.12 Theexec()library functions6-58\n\nTheexec()library functions\n#include<unistd.h>\nintexecle(const char*pathname,const char*arg, ...\n/* , (char *) NULL, char *const envp[] */ );\nintexeclp(const char*filename,const char*arg, ...\n/* , (char *) NULL */);\nintexecvp(const char*filename,char*constargv[]);\nintexecv(const char*pathname,char*constargv[]);\nintexecl(const char*pathname,const char*arg, ...\n/* , (char *) NULL */);\nintexecvpe(const char*filename,const*charargv[],\nchar*constenvp[]);\nVariations on theme ofexecve()\nLikeexecve(), theexec()functions return only if they fail\nexecvpe()is Linux-specific (define_GNU_SOURCE)\nSystem Programming Essentials©2025 M. KerriskProcess Lifecycle6-59  §6.12\nTheexec()library functions\nVary theme ofexecve()with 2 choices in each of 3 dimensions:\nHow are command-line arguments of new program specified?\nHow is the executable specified?\nHow is environment of new program specified?\nFinal letters in name of each function indicate behavior\nFunctionSpecification\nof arguments\n(v, l)\nSpecification\nof executable\nfile (-, p)\nSource of\nenvironment\n(e, -)\nexecve()arraypathnameenvpargument\nexecle()listpathnameenvpargument\nexeclp()listfilename +PATHcaller’senviron\nexecvp()arrayfilename +PATHcaller’senviron\nexecv()arraypathnamecaller’senviron\nexecl()listpathnamecaller’senviron\nexecvpe()arrayfilename +PATHenvpargument\nSystem Programming Essentials©2025 M. KerriskProcess Lifecycle6-60  §6.12\n\nLinux System Programming Essentials\nSystem Call Tracing withstrace\nMichael Kerrisk, man7.org©2025\nAugust 2025\nmtk@man7.org\nOutlineRev: # caf166f4161b\n7  System Call Tracing withstrace7-1\n7.1 Getting started7-3\n7.2 Tracing child processes7-11\n7.3 Exercises7-15\n7.4 Filteringstraceoutput7-17\n7.5 System call tampering7-23\n7.6 Furtherstraceoptions7-29\n\nOutline\n7  System Call Tracing withstrace7-1\n7.1 Getting started7-3\n7.2 Tracing child processes7-11\n7.3 Exercises7-15\n7.4 Filteringstraceoutput7-17\n7.5 System call tampering7-23\n7.6 Furtherstraceoptions7-29\nstrace(1)\nA tool to trace system calls made by a user-space process\nImplemented viaptrace(2)\nhttps://strace.io/\nOr: a debugging tool for tracingcomplete conversation\nbetween application and kernel\nApplication source code is not required\nAnswer questions like:\nWhat system calls are employed by application?\nWhich files does application touch?\nWhat arguments are being passed to each system call?\nWhich system calls are failing, and why (errno)?\nSee also the loosely relatedltrace(1)command\nTrace function calls in shared libraries (e.g., libc)\nSystem Programming Essentials©2025 M. KerriskSystem Call Tracing withstrace7-4  §7.1\n\nstrace(1)\nTrace information is provided insymbolic form\nSystem call namesare shown\nWe seesignal names(not numbers)\nStringsprinted as characters (up to 32 bytes, by default)\nBit-mask arguments displayed symbolically, using\ncorresponding bit flag names ORed together\nStructuresdisplayed withlabeled fields\n“Large” arguments are abbreviated by default\nUsestrace –v(verbose) to see unabbreviated arguments\nSystem Programming Essentials©2025 M. KerriskSystem Call Tracing withstrace7-5  §7.1\nstrace(1)\nfstat(3, {st_dev=makedev(0x8, 0x5), st_ino=407279,\nst_mode=S_IFREG|0755, st_nlink=1, st_uid=0, st_gid=0,\nst_blksize=4096, st_blocks=80, st_size=36960, st_atime=1625615479\n/* 2021-07-07T01:51:19.795021222+0200 */, st_atime_nsec=795021222,\nst_mtime=1613345143 /* 2021-02-15T00:25:43+0100 */, st_mtime_nsec=0,\nst_ctime=1616161103 /* 2021-03-19T14:38:23.816838407+0100 */,\nst_ctime_nsec=816838407}) = 0\nopen(\"/lib64/liblzma.so.5\", O_RDONLY|O_CLOEXEC) = 3\naccess(\"/etc/ld.so.preload\", R_OK)      = -1 ENOENT(Nosuchfileor\ndirectory)\nFor each system call, we see:\nName of system call\nValues passed in/returned via arguments\nSystem call return value\nSymbolicerrnovalue (+ explanatory text) on syscall failures\nSystem Programming Essentials©2025 M. KerriskSystem Call Tracing withstrace7-6  §7.1\n\nSimple usage: tracing a command at the command line\nA very simple C program:\nintmain(intargc,char*argv[]) {\n#defineSTR \"Hello world\\n\"\nwrite(STDOUT_FILENO, STR, strlen(STR));\nexit(EXIT_SUCCESS);\n}\nRunstrace(1), directing logging output (–o) to a file:\n$ strace -o strace.log ./hello_world\nHello world\n(By default, trace output goes to standard error)\n\"\nOn some systems, may first need to to ensure\nptrace_scopefile has value 0 or 1:\n$ sudo sh -c'echo 0 > /proc/sys/kernel/yama/ptrace_scope'\nYama LSM disablesptrace(2)to prevent attack escalation;\nseeptrace(2)manual page\nSystem Programming Essentials©2025 M. KerriskSystem Call Tracing withstrace7-7  §7.1\nSimple usage: tracing a command at the command line\n$ cat strace.log\nexecve(\"./hello_world\", [\"./hello_world\"], [/* 110 vars */]) = 0\n...\naccess(\"/etc/ld.so.preload\", R_OK)= -1 ENOENT (No such file or directory)\nopen(\"/etc/ld.so.cache\", O_RDONLY|O_CLOEXEC) = 3\nfstat(3, {st_mode=S_IFREG|0644, st_size=160311, ...}) = 0\nmmap(NULL, 160311, PROT_READ, MAP_PRIVATE, 3, 0) = 0x7fa5ecfc0000\nclose(3)= 0\nopen(\"/lib64/libc.so.6\", O_RDONLY|O_CLOEXEC) = 3\n...\nwrite(1, \"Hello world\\n\", 12)= 12\nexit_group(0)= ?\n+++ exited with 0 +++\nEven simple programs make lots of system calls!\n25 in this case (many have been edited from above output)\nMost output in this trace relates to finding and loading\nshared libraries\nFirst call (execve()) was used by shell to load our program\nOnly last two system calls were made by our program\nSystem Programming Essentials©2025 M. KerriskSystem Call Tracing withstrace7-8  §7.1\n\nA gotcha...\nThe last call in our program was:\nexit(EXIT_SUCCESS);\nButstraceshowed us:\nexit_group(0)                           = ?\nSome detective work:\nWe “know”exit(3)is a library function that calls_exit(2)\nBut where didexit_group()come from?\n_exit(2)manual page tells us:\n$ man 2 _exit\n...\nClibrary/kerneldifferences\nIn glibc up to version 2.3, the _exit() wrapper function\ninvoked  the kernel system call of the same name.  Since\nglibc 2.3, the wrapper function  invokes  exit_group(2),\nin order to terminate all of the threads in a process.\n⇒may need to dig deeper to understandstrace(1)output\nSystem Programming Essentials©2025 M. KerriskSystem Call Tracing withstrace7-9  §7.1\nTracing live processes\n–p PID:trace running processwith specified PID\nTypeControl-Cto cease tracing\nTotrace multiple processes, specify–pmultiple times\nCan trace only processes you own\n(And a process can have only one tracer)\n\"\"\ntracing a process canheavily affect performance\nE.g., up to two orders of magnitude slow-down in syscalls\n\"\nThink twice before using in a production environment\n–p PID –f: willtrace all threadsin specified process\nSystem Programming Essentials©2025 M. KerriskSystem Call Tracing withstrace7-10  §7.1\n\nOutline\n7  System Call Tracing withstrace7-1\n7.1 Getting started7-3\n7.2 Tracing child processes7-11\n7.3 Exercises7-15\n7.4 Filteringstraceoutput7-17\n7.5 System call tampering7-23\n7.6 Furtherstraceoptions7-29\nTracing child processes\nBy default,stracedoes not trace children of traced process\n–foption causes children to be traced\nEach trace line is prefixed by PID\nIn a program that employs POSIX threads, each line shows\nkernel thread ID (gettid())\nSystem Programming Essentials©2025 M. KerriskSystem Call Tracing withstrace7-12  §7.2\n\nTracing child processes:strace/fork_exec.c\n1intmain(intargc,char*argv[]) {\n2     pid_t childPid;\n3char*newEnv[] = {\"ONE=1\", \"TWO=2\", NULL};\n5     printf(\"PID of parent: %ld\\n\", (long) getpid());\n6     childPid = fork();\n7if(childPid == 0) {        /* Child */\n8         printf(\"PID of child:  %ld\\n\", (long) getpid());\n9if(argc > 1) {\n10             execve(argv[1], &argv[1], newEnv);\n11             errExit(\"execve\");\n12         }\n13         exit(EXIT_SUCCESS);\n14     }\n15     wait(NULL);         /* Parent waits for child */\n16     exit(EXIT_SUCCESS);\n17 }\n$ strace -f -o strace.log ./fork_exec\nPID of parent: 1939\nPID of child:  1940\nSystem Programming Essentials©2025 M. KerriskSystem Call Tracing withstrace7-13  §7.2\nTracing child processes:strace/fork_exec.c\n$ cat strace.log\n1939 execve(\"./fork_exec\", [\"./fork_exec\"], [/* 110 vars */]) = 0\n...\n1939 clone(child_stack=0, flags=CLONE_CHILD_CLEARTID|CLONE_CHILD_SETTID|SIGCHLD,\nchild_tidptr=0x7fe484b2ea10) = 1940\n1939 wait4(-1,  <unfinished...>\n1940 write(1, \"PID of child:  1940\\n\", 21) = 21\n1940 exit_group(0)= ?\n1940 +++ exited with 0 +++\n1939 <... wait4resumed> NULL, 0, NULL) = 1940\n1939 --- SIGCHLD{si_signo=SIGCHLD, si_code=CLD_EXITED, si_pid=1940,\nsi_uid=1000, si_status=0, si_utime=0, si_stime=0} ---\n1939 exit_group(0)= ?\n1939 +++ exited with 0 +++\nEach line of trace output is prefixed with corresponding PID\nInside glibc,fork()is actually a wrapper that callsclone(2)\nwait()is a wrapper that callswait4(2)\nWe see two lines of output forwait4()because call blocks\nand then resumes\nstraceshows us that parent received aSIGCHLDsignal\nSystem Programming Essentials©2025 M. KerriskSystem Call Tracing withstrace7-14  §7.2\n\nOutline\n7  System Call Tracing withstrace7-1\n7.1 Getting started7-3\n7.2 Tracing child processes7-11\n7.3 Exercises7-15\n7.4 Filteringstraceoutput7-17\n7.5 System call tampering7-23\n7.6 Furtherstraceoptions7-29\nExercises\nTry usingstraceto trace the execution of a program of your\nchoice.\nSome amusements (may require the value 0 in\n/proc/sys/kernel/yama/ptrace_scope):\nstrace -p $$\nstrace strace -p $$\nSystem Programming Essentials©2025 M. KerriskSystem Call Tracing withstrace7-16  §7.3\n\nOutline\n7  System Call Tracing withstrace7-1\n7.1 Getting started7-3\n7.2 Tracing child processes7-11\n7.3 Exercises7-15\n7.4 Filteringstraceoutput7-17\n7.5 System call tampering7-23\n7.6 Furtherstraceoptions7-29\nSelecting system calls to be traced\nstrace –ecan be used to select system calls to be traced\n–e trace=<syscall>[,<syscall>...]\nSpecify system call(s) that should be traced\nOther system calls are ignored\n$ strace -o strace.log -e trace=open,close ls\n–e trace=!<syscall>[,<syscall>...]\nExcludespecified system call(s) from tracing\nSome applications do bizarre things (e.g., calling\ngettimeofday()1000s of times/sec.)\n\"\n“!” needs to be quoted to avoid shell interpretation\n–e trace=/<regexp>\nTrace syscalls whose names match regular expression\nApril 2017; expression will probably need to be quoted...\nSystem Programming Essentials©2025 M. KerriskSystem Call Tracing withstrace7-18  §7.4\n\nSelecting system calls by category\n–e trace=<syscall-category>trace a category of syscalls\nCategories include:\n%file: trace all syscalls that take a filename as argument\nopen(),stat(),truncate(),chmod(),setxattr(),link()...\n%desc: trace file-descriptor-related syscalls\nread(),write(),open(),close(),fsetxattr(),poll(),select(),\npipe(),fcntl(),epoll_create(),epoll_wait()...\n%process: trace process management syscalls\nfork(),clone(),exit_group(),execve(),wait4(),unshare()...\n%network: trace network-related syscalls\nsocket(),bind(),listen(),connect(),sendmsg()...\n%signal: trace signal-related syscalls\nkill(),rt_sigaction(),rt_sigprocmask(),rt_sigqueueinfo()...\n%memory: trace memory-mapping-related syscalls\nmmap(),mprotect(),mlock()...\nSystem Programming Essentials©2025 M. KerriskSystem Call Tracing withstrace7-19  §7.4\nFiltering signals\nstrace –e signal=set\nTrace only specified set of signals\n“sig” prefix in names is optional; following are equivalent:\n$ strace -e signal=sigio,sigintls > /dev/null\n$ strace -e signal=io,intls > /dev/null\nstrace –e signal=!set\nExclude specified signals from tracing\nSystem Programming Essentials©2025 M. KerriskSystem Call Tracing withstrace7-20  §7.4\n\nFiltering by pathname\nstrace –P pathname: trace only system calls that access file\natpathname\nSpecify multiple–Poptions to trace multiple paths\nExample:\n$ strace -o strace.log -P /lib64/libc.so.6 ls > /dev/null\nRequested path'/lib64/libc.so.6'resolved into'/usr/lib64/libc-2.18.so'\n$ cat strace.log\nopen(\"/lib64/libc.so.6\", O_RDONLY|O_CLOEXEC) = 3\nread(3, \"\\177ELF\\2\\1\\1\\3\\0\\0\\0\\0\\0\\0\\0\\0\\3\\0>\\0\\1\\0\\0\\0p\\36\\2\\0\\0\\0\\0\\0\"...,\n832) = 832\nfstat(3, {st_mode=S_IFREG|0755, st_size=2093096, ...}) = 0\nmmap(NULL, 3920480, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE,\n3, 0) = 0x7f8511fa3000\nmmap(0x7f8512356000, 24576, PROT_READ|PROT_WRITE,\nMAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x1b3000) = 0x7f8512356000\nclose(3)= 0\n+++ exited with 0 +++\nstracenoticed that the specified file was opened on FD 3,\nand also traced operations on that FD\nSystem Programming Essentials©2025 M. KerriskSystem Call Tracing withstrace7-21  §7.4\nMapping file descriptors to pathnames\n–yoption causesstraceto display pathnames corresponding\nto each file descriptor\nUseful info is also displayed for other types of file descriptors,\nsuch as pipes and sockets\n$ strace -y cat greet\n...\nopenat(AT_FDCWD, \"greet\", O_RDONLY)    = 3</home/mtk/greet>\nfstat(3</home/mtk/greet>, {st_mode=S_IFREG|0644, ...\nread(3</home/mtk/greet>, \"hello world\\n\", 131072) = 12\nwrite(1</dev/pts/11>, \"hello world\\n\", 12) = 12\nread(3</home/mtk/greet>, \"\", 131072) = 0\nclose(3</home/mtk/greet>)    = 0\n...\n–yyis as for–ybut shows additional protocol-specific info for\nsockets\nwrite(3<TCP:[10.0.20.135:33522->213.131.240.174:80]>,\n\"GET / HTTP/1.1\\r\\nUser-Agent: Wget\"..., 135) = 135\nread(3<TCP:[10.0.20.135:33522->213.131.240.174:80]>,\n\"HTTP/1.1 200 OK\\r\\nDate: Thu, 19 J\"..., 253) = 253\nSystem Programming Essentials©2025 M. KerriskSystem Call Tracing withstrace7-22  §7.4\n\nOutline\n7  System Call Tracing withstrace7-1\n7.1 Getting started7-3\n7.2 Tracing child processes7-11\n7.3 Exercises7-15\n7.4 Filteringstraceoutput7-17\n7.5 System call tampering7-23\n7.6 Furtherstraceoptions7-29\nSystem call tampering\nstracecan be used tomodifybehavior of selected syscall(s)\nInitial feature implementation completed in early 2017\nVarious possible effects:\nInject delay before/after syscall\nGenerate a signal on syscall\nBypass execution of syscall, making it return a “success”\nvalue or fail with specified value inerrno(error injection)\n(Limited) ability to choose which invocation of syscall will be\nmodified\nSystem Programming Essentials©2025 M. KerriskSystem Call Tracing withstrace7-24  §7.5\n\nstrace -e injectoptions\nSyntax:strace -e inject=<syscall-set>[:<option>]...\nsyscall-setis set of syscalls whose behavior will be modified\n:error=errnum: syscall is not executed; returns failure\nstatus witherrnoset as specified\n:retval=value: syscall is not executed; returns specified\n“success” value\nCan’t specify both:retvaland:errortogether\nSystem Programming Essentials©2025 M. KerriskSystem Call Tracing withstrace7-25  §7.5\nstrace -e injectoptions\n:signal=sig: deliver specified signal on entry to syscall\n:delay_enter=usecs,:delay_exit=usecs: delay forusecs\nmicroseconds on entry to/return from syscall\n:when=expr: specify which invocation(s) to tamper with\n:when=N: tamper with invocationN\n:when=N+: tamper starting atNth invocation\n:when=N+S: tamper with invocationN, and then everyS\ninvocations\nRange ofNandSis 1..65535\nSystem Programming Essentials©2025 M. KerriskSystem Call Tracing withstrace7-26  §7.5\n\nExample\n$ strace -y-e close -einject=close:error=22:when=3/bin/ls > d\nclose(3</etc/ld.so.cache>)= 0\nclose(3</usr/lib64/libselinux.so.1>)   = 0\nclose(3</usr/lib64/libcap.so.2.25>)    =  -1EINVAL(Invalidargument)(INJECTED)\nclose(3</usr/lib64/libcap.so.2.25>)    = 0\n/bin/ls: errorwhileloading shared libraries: libcap.so.2:\ncannot close file descriptor: Invalid argument\n+++ exited with 127 +++\nUse–yto show pathnames corresponding to file descriptors\nInject error 22 (EINVAL) on third call toclose()\nThirdclose()was not executed; an error return was injected\n(After that,lsgot sad)\nSystem Programming Essentials©2025 M. KerriskSystem Call Tracing withstrace7-27  §7.5\nUsing system call tampering for error injection\nSuccess-injection example: makeunlinkat()succeed, without\ndeleting temporary file that would have been deleted\nError-injection use case: quick and simple black-box testing\nDoes application fail gracefully when encountering\nunexpected error?\nBut there are alternatives for black-box testing:\nPreloaded library with interposing wrapper function that\nspoofs a failure (without calling “real” function)\nCan be more flexible\nBut can’t be used with set-UID/set-GID programs\nSeccomp (secure computing)\nGeneralized facility to block execution of system calls based\non system call number and argument values\nMore powerful, but can’t, for example cause Nth call to fail\nSystem Programming Essentials©2025 M. KerriskSystem Call Tracing withstrace7-28  §7.5\n\nOutline\n7  System Call Tracing withstrace7-1\n7.1 Getting started7-3\n7.2 Tracing child processes7-11\n7.3 Exercises7-15\n7.4 Filteringstraceoutput7-17\n7.5 System call tampering7-23\n7.6 Furtherstraceoptions7-29\nObtaining a system call summary\nstrace –ccounts time, calls, and errors for each system call\nand reports a summary on program exit\n$ strace -c who > /dev/null\n% time     seconds  usecs/call     calls    errors syscall\n------ ----------- ----------- --------- --------- --------------\n21.77    0.000648           9        72           alarm\n14.42    0.000429           9        48           rt_sigaction\n13.34    0.000397           8        48           fcntl\n8.84    0.000263           5        48           read\n7.29    0.000217          13        17         2 kill\n6.79    0.000202           6        33         1 stat\n5.41    0.000161           5        31           mmap\n4.44    0.000132           4        31         6 open\n2.89    0.000086           3        29           close\n...\n------ ----------- ----------- --------- --------- --------------\n100.00    0.002976                   442        13 total\nTreat time measurements as indicative only, sincestraceadds\noverhead to each syscall\nSystem Programming Essentials©2025 M. KerriskSystem Call Tracing withstrace7-30  §7.6\n\nFurtherstraceoptions\n–k: print a stack trace after each traced syscall\nsudo strace –u <username> prog: run program with UID\nand GIDs of specified user\nUseful when tracing privileged programs, such as\nset-UID-rootprograms\nNormally, privileged programs arenotrun with privilege when\nexecuted understrace\nSystem Programming Essentials©2025 M. KerriskSystem Call Tracing withstrace7-31  §7.6\nFurtherstraceoptions\n–v: don’t abbreviate arguments (structures, etc.)\nOutput can be quite verbose...\n–s strsize: maximum number of bytes to display for strings\nDefault is 32 characters\nPathnames are always printed in full\nVarious options show start time or duration of system calls\n–t,–tt: prefix each trace line with wall-clock time\n–ttalso adds microseconds\n–T: show time spent in syscall\nBut treat as indications only, sincestracecauses overhead on\nsyscalls\nSystem Programming Essentials©2025 M. KerriskSystem Call Tracing withstrace7-32  §7.6\n\nLinux System Programming Essentials\nWrapup\nMichael Kerrisk, man7.org©2025\nAugust 2025\nmtk@man7.org\nOutlineRev: # caf166f4161b\n8  Wrapup8-1\n8.1 Wrapup8-3\n\nOutline\n8  Wrapup8-1\n8.1 Wrapup8-3\nCourse materials\nI’m the (sole) producer of the course book and example\nprograms\nCourse materials are continuously revised\nSend corrections and suggestions for improvements to\nmtk@man7.org\nSystem Programming Essentials©2025 M. KerriskWrapup8-4  §8.1\n\nMarketing\nIndependent trainer, consultant, and writer\nAuthor ofThe Linux Programming Interface\nReputation / word-of-mouth are important for my business...\nLet people know about these courses!\nLinux/UNIX system programming\nLinux security and isolation APIs\nNamespaces, cgroups, seccomp, and capabilities\nSystem programming for Linux containers\nBuilding and using shared libraries\nLinux/UNIX network programming\nTCP/IP fundamentals\nSubsets/combinations of the above;see next slide\nFurther courses to be announced:http://man7.org/training/\nSystem Programming Essentials©2025 M. KerriskWrapup8-5  §8.1\nCourse overview (seehttps://man7.org/training)\nLinux/UNIX System Programming(LUSP01, 5 days)\nSystem Programming Fundamentals\n(SPINTRO01, 2 days)\nThreads and IPC Programming\n(TIPC01, 3 days)\nIPC Programming\n(IPC02, 3 days)\nPOSIX Threads\n(PTHR01, 1 day)\nSystem Programming for Linux Containers(SPLC02, 5 days)\nLinux Security and Isolation APIs(SECISOL02, 4 days)\nCapabilities + Namespaces\n(CAPNS01, 2 days)\nSeccomp\n(SECCOMP01, 1d)\nControl Groups\n(CGROUPS02, 1d)\nSystem Prog.\nEssentials\n(SPESS01, 1d)\nLinux/UNIX Network\nProg.(NWP03, 3 days)\nTCP/IP Fundamentals\n(TCPIP01, 1 day)\nLinux Shared Libraries\n(SHLIB04, 2.5 days)\nNesting indicates a topic that can be taken either as a\nseparate course or as part of a longer course\nArrows show a suggested prerequisite course\n\nThanks!\nmtk@man7.org   @mkerrisk   linkedin.com/in/mkerrisk\nPGP fingerprint: 4096R/3A35CE5E\nhttp://man7.org/training/\n(New Zealand Little Blue Penguins)\nThis page intentionally blank"
    }
  ]
}